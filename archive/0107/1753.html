<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="generator" content="hypermail 2.1.5, see http://www.hypermail.org/">
<title>SL4: Re: Flare</title>
<meta name="Author" content="Simon McClenahan (peepsplat@yahoo.com)">
<meta name="Subject" content="Re: Flare">
<meta name="Date" content="2001-07-16">
<style type="text/css">
body {color: black; background: #ffffff}
h1.center {text-align: center}
div.center {text-align: center}
</style>
</head>
<body>
<h1>Re: Flare</h1>
<!-- received="Tue Jul 17 01:38:17 2001" -->
<!-- isoreceived="20010717073817" -->
<!-- sent="Mon, 16 Jul 2001 22:14:03 -0500" -->
<!-- isosent="20010717031403" -->
<!-- name="Simon McClenahan" -->
<!-- email="peepsplat@yahoo.com" -->
<!-- subject="Re: Flare" -->
<!-- id="009d01c10e6e$886e3580$0c01a8c0@ce.mediaone.net" -->
<!-- charset="iso-8859-1" -->
<!-- inreplyto="3B5334BD.C6BE1E4E@pobox.com" -->
<!-- expires="-1" -->
<p>
<strong>From:</strong> Simon McClenahan (<a href="mailto:peepsplat@yahoo.com?Subject=Re:%20Flare"><em>peepsplat@yahoo.com</em></a>)<br>
<strong>Date:</strong> Mon Jul 16 2001 - 21:14:03 MDT
</p>
<!-- next="start" -->
<ul>
<li><strong>Next message:</strong> <a href="1754.html">Ben Goertzel: "RE: Flare"</a>
<li><strong>Previous message:</strong> <a href="1752.html">Eliezer S. Yudkowsky: "PROJ: Flare"</a>
<li><strong>In reply to:</strong> <a href="1752.html">Eliezer S. Yudkowsky: "PROJ: Flare"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="1754.html">Ben Goertzel: "RE: Flare"</a>
<li><strong>Reply:</strong> <a href="1754.html">Ben Goertzel: "RE: Flare"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#1753">[ date ]</a>
<a href="index.html#1753">[ thread ]</a>
<a href="subject.html#1753">[ subject ]</a>
<a href="author.html#1753">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<hr>
<!-- body="start" -->
<p>
<em>&gt; (For those of you who are wondering what &quot;Flare&quot; is, &quot;Flare&quot; is a proposal
</em><br>
<em>&gt; for a new programming language
</em><br>
<p>I know I'm sounding like a cynic here, but why do we need yet another
<br>
programming language? I will admit, it's been a while (a decade) since I've
<br>
looked at LISP, and I may be a lot more familiar procedural programming and with
<br>
object-oriented programming in C++ and Java, but I still find it difficult to
<br>
justify YAPL.
<br>
<p><p><em>&gt; that the Singularity Institute would like
</em><br>
<em>&gt; to have on hand for AI, both because there are specific features required,
</em><br>
<em>&gt; and because we need more powerful programming tools in general. In
</em><br>
<em>&gt; dialects of LISP, both the program and the program data are represented as
</em><br>
<em>&gt; lists.  In Flare, the program, program data, and ideally the program
</em><br>
<em>&gt; state, are all represented as well-formed XML.  Flare would be run as an
</em><br>
<em>&gt; open-source project.)
</em><br>
<p>I know you've only written preliminary documentation and very little
<br>
specification, but as one programmer to another, I would like to see some more
<br>
specific examples to justify us humans learning another language to program
<br>
computers with. Shouldn't we write the Seed AI and Friendly AI in a language
<br>
that is common and familiar? Writing the code in something more obtuse will
<br>
allow only specialist humans to be able to write and debug the code.
<br>
<p><p><p>I am far from being an expert in programming language design, but I have made
<br>
interesting discoveries in the area. I hope there are more qualified people on
<br>
the list that could comment on my statements. I was introduced to the concept of
<br>
meta-programming when I discovered a language called Pliant <a href="http://pliant.cx/">http://pliant.cx/</a> .
<br>
I will cut and paste key bits of information I find interesting at the end of
<br>
this email.
<br>
<p><p>One thing that has always bugged me about programming languages is the fact that
<br>
they are all text-based. When I started learning the graphical Unified Modelling
<br>
Language (UML), I could see much more clearly the relationships between objects
<br>
in a system through the use of both static and dynamic analysis diagrams. The
<br>
current specification may not be detailed enough to be considered a language for
<br>
programming yet, but I have a feeling that pushed to its limits, it could be. I
<br>
think that the UML can evolve as a modelling language to programming language.
<br>
<p>As for an XML representation, maybe there is something in the XMI standard,
<br>
which allows development tools such as modellers and programming IDE's to
<br>
exchange information.
<br>
<p>I prefer to think of myself as a Software Engineer rather than a Software
<br>
Programmer. &quot;Design first, implement later,&quot; and all those other cliches and
<br>
Right Things to do when building complex systems.
<br>
<p><p>The upshot of this email is that if I was to design a new language, I would do a
<br>
lot more research on meta-programming. From what I recall, Pliant is but one
<br>
language designed with this concept in mind. It would be futile to re-invent the
<br>
wheel, although I do admit that I am assuming those involved with Flare are not
<br>
aware or have not investigated this concept.
<br>
<p><p>cheers,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Simon
<br>
<p><p><p>---------------------------------------------------------
<br>
<a href="http://pliant.cx/pliant/welcome/philosophy.html">http://pliant.cx/pliant/welcome/philosophy.html</a>
<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What is a program?
<br>
<p>My personal answer is:
<br>
For a human, it is a set of expressions. Each expression is either a raw datum,
<br>
or a keyword, with a set of subexpressions (arguments), where the keyword is
<br>
providing the semantics for the expression.
<br>
For a computer, a program is a set of instructions. Each instruction is a
<br>
function call, with a set of parameters and eventually a switch to another
<br>
instruction, each parameter being a datum. Some of the functions are programs
<br>
(and thus sets of instructions), and some are hardcoded.
<br>
Now, Pliant is the bridge between the two. Prior languages focus either on the
<br>
semantics, pretending that a program is a set of expressions (Lisp) and so fail
<br>
to get efficient handling by a computer, or focus on efficiency, pretending that
<br>
a program is a set of instructions (C) and so fail to get efficient handling by
<br>
a human.
<br>
<p>A language is a bridge between the human way of coding a program and the
<br>
computer way. I assert that Pliant is the best way now available, because it
<br>
addresses the bridging goal with the highest level of flexibility.
<br>
<p>---------------------------------------------------------
<br>
<a href="http://pliant.cx/pliant/welcome/whatisit.html">http://pliant.cx/pliant/welcome/whatisit.html</a>
<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pliant features summary
<br>
<p><p>As a summary: Pliant is typed-Lisp + C++ + reflective-C in one language:
<br>
<p>A few more key Pliant aspects: Pliant is
<br>
<p>A modern logical programming language: Lisp lists are back in Pliant as the
<br>
'Expression' data type, which moreover introduces typing just like modern
<br>
logical programming languages
<br>
A full-featured, efficient programming language: C++ equivalent without the set
<br>
of horrible things: preprocessor, crazy syntax, inefficiency due to nouse object
<br>
copies
<br>
A fine scripting language since small applications can be written in very few
<br>
lines (see the Pliant forum application), you need no compiling step (it is done
<br>
on the fly), the debugger is integrated (not an external tool), and, it runs
<br>
fast and scales well ...
<br>
The first language well suited to very large applications, because (1) it's
<br>
module model is very extensible (separated namespaces, and parser and optimizer)
<br>
and then (2) a library (module) can check the consistency and rewrite on the fly
<br>
(for optimizing) the programs that use it.
<br>
<p>A few more details for more technical readers:
<br>
<p>The first few lines on this page clearly mean that Pliant is reflective: the
<br>
program is the data.
<br>
In Pliant, everything is an object, including functions and data types, so a
<br>
Pliant function call can be compiled, then executed, then freed.
<br>
Pliant syntax is roughly an extension of Lisp syntax (an example).
<br>
Meta programming enables lazy evaluation wherever it is needed.
<br>
Pliant eliminates the preprocessor and make since, as a dynamic compiler, Pliant
<br>
can check details about the machine it runs on, much as some applications can do
<br>
at run time: it may be the first non-blind compiler.
<br>
<p><p><p>----------------------------------------------------------
<br>
<a href="http://pliant.cx/pliant/welcome/design.html">http://pliant.cx/pliant/welcome/design.html</a>
<br>
Lots of good stuff here
<br>
<p>Conclusion: Pliant's place in the evolution of languages
<br>
<p><p><p>Pliant's author views the main steps in programming language evolution as:
<br>
No abstraction: Machine code
<br>
Human readable notation of hardware instructions: Assembly
<br>
Abstract instruction sets: COBOL, FORTRAN, Basic
<br>
Functions with prototype and private variables: Pascal, C
<br>
Types with embedded low level management: Object languages: Smalltalk, C++,
<br>
Eiffel
<br>
Library can check and (re)write the program using it: Meta programming language:
<br>
Pliant
<br>
Two stage programming model: Brain model languages
<br>
So, Pliant is likely not the ultimate way to program, but it may be as long as
<br>
computer parallelism is far less than in brains.
<br>
Up to the limits of the sequential programming model, Pliant enables inventing
<br>
new ways to program by including new modules rather than moving to another
<br>
language. Far more important, various parts of an application can be written in
<br>
various programming styles, and still work perfectly together. This is what
<br>
Pliant truly does and truly is designed for.
<br>
<p>The ability to make several pieces of code written with different programming
<br>
styles (so different languages) work together was previously assumed by the
<br>
linker, but it was a nightmare to use practically since an application is not
<br>
only some binary code, but also a set of prototypes, data types, and constants
<br>
that had to be written in every language. Pliant enables writing all these
<br>
things in any of them and using them in all others, or even to generate them as
<br>
a result of computations.
<br>
Rather than being a true language, Pliant is a very general language framework
<br>
that can be customized very deeply to match specific needs. In Pliant, most
<br>
parts are not in the compiler executable, but rather in the modules, so the
<br>
right question for programmers may not be:
<br>
Should I use Pliant or another language ?
<br>
but rather:
<br>
What Pliant modules should I use ?
<br>
<p>Hope you have been interested by these fairly abstract considerations and are
<br>
now ready to study how Pliant truly works.
<br>
<p><p>----------------------------------------------------------------
<br>
<!-- body="end" -->
<hr>
<ul>
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="1754.html">Ben Goertzel: "RE: Flare"</a>
<li><strong>Previous message:</strong> <a href="1752.html">Eliezer S. Yudkowsky: "PROJ: Flare"</a>
<li><strong>In reply to:</strong> <a href="1752.html">Eliezer S. Yudkowsky: "PROJ: Flare"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="1754.html">Ben Goertzel: "RE: Flare"</a>
<li><strong>Reply:</strong> <a href="1754.html">Ben Goertzel: "RE: Flare"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#1753">[ date ]</a>
<a href="index.html#1753">[ thread ]</a>
<a href="subject.html#1753">[ subject ]</a>
<a href="author.html#1753">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<!-- trailer="footer" -->
<hr>
<p><small><em>
This archive was generated by <a href="http://www.hypermail.org/">hypermail 2.1.5</a> 
: Wed Jul 17 2013 - 04:00:36 MDT
</em></small></p>
</body>
</html>
