<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="generator" content="hypermail 2.1.5, see http://www.hypermail.org/">
<title>SL4: Re: [sl4] Rolf's gambit revisited</title>
<meta name="Author" content="Norman Noman (overturnedchair@gmail.com)">
<meta name="Subject" content="Re: [sl4] Rolf's gambit revisited">
<meta name="Date" content="2009-01-12">
<style type="text/css">
body {color: black; background: #ffffff}
h1.center {text-align: center}
div.center {text-align: center}
</style>
</head>
<body>
<h1>Re: [sl4] Rolf's gambit revisited</h1>
<!-- received="Mon Jan 12 02:12:02 2009" -->
<!-- isoreceived="20090112091202" -->
<!-- sent="Mon, 12 Jan 2009 03:12:00 -0600" -->
<!-- isosent="20090112091200" -->
<!-- name="Norman Noman" -->
<!-- email="overturnedchair@gmail.com" -->
<!-- subject="Re: [sl4] Rolf's gambit revisited" -->
<!-- id="46208cc60901120112k7689b6faj262b768430a85e4f@mail.gmail.com" -->
<!-- charset="ISO-8859-1" -->
<!-- inreplyto="ff7ba12a0901060747h6338a0a8je68d9b3af68affb7@mail.gmail.com" -->
<!-- expires="-1" -->
<p>
<strong>From:</strong> Norman Noman (<a href="mailto:overturnedchair@gmail.com?Subject=Re:%20[sl4]%20Rolf's%20gambit%20revisited"><em>overturnedchair@gmail.com</em></a>)<br>
<strong>Date:</strong> Mon Jan 12 2009 - 02:12:00 MST
</p>
<!-- next="start" -->
<ul>
<li><strong>Next message:</strong> <a href="19717.html">Norman Noman: "Re: [sl4] Rolf's gambit revisited"</a>
<li><strong>Previous message:</strong> <a href="19715.html">Ben Goertzel: "[sl4] time-sensitive issue: voting members sought to participate in upcoming election for H+ (World Transhumanist Association)"</a>
<li><strong>In reply to:</strong> <a href="19705.html">Benja Fallenstein: "Re: [sl4] Rolf's gambit revisited"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="19718.html">Matt Mahoney: "Re: [sl4] Rolf's gambit revisited"</a>
<li><strong>Reply:</strong> <a href="19718.html">Matt Mahoney: "Re: [sl4] Rolf's gambit revisited"</a>
<li><strong>Reply:</strong> <a href="19725.html">Benja Fallenstein: "Re: [sl4] Rolf's gambit revisited"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#19716">[ date ]</a>
<a href="index.html#19716">[ thread ]</a>
<a href="subject.html#19716">[ subject ]</a>
<a href="author.html#19716">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<hr>
<!-- body="start" -->
<p>
On Tue, Jan 6, 2009 at 9:47 AM, Benja Fallenstein &lt;
<br>
<a href="mailto:benja.fallenstein@gmail.com?Subject=Re:%20[sl4]%20Rolf's%20gambit%20revisited">benja.fallenstein@gmail.com</a>&gt; wrote:
<br>
<p><em>&gt; Hi all,
</em><br>
<em>&gt;
</em><br>
<em>&gt; (New here. *waves*)
</em><br>
<em>&gt;
</em><br>
<em>&gt; Peter de Blanc wrote:
</em><br>
<em>&gt; &gt; Mike Dougherty wrote:
</em><br>
<em>&gt; &gt;&gt; Peter de Blanc wrote:
</em><br>
<em>&gt; &gt;&gt;&gt; Matt Mahoney wrote:
</em><br>
<em>&gt; &gt;&gt;&gt;
</em><br>
<em>&gt; &gt;&gt;&gt;&gt; False. If X simulates Y, then K(X) &gt; K(Y) because X has an exact model
</em><br>
<em>&gt; &gt;&gt;&gt;&gt; of the mental state of Y. This implies that Y cannot also simulate X
</em><br>
<em>&gt; &gt;&gt;&gt;&gt; because it would require K(Y) &gt; K(X).
</em><br>
<em>&gt; &gt;&gt;&gt;
</em><br>
<em>&gt; &gt;&gt;&gt; Matt, please stop posting pseudomathematics.
</em><br>
<em>&gt; &gt;&gt;
</em><br>
<em>&gt; &gt;&gt; Seriously? [...]
</em><br>
<em>&gt; &gt;
</em><br>
<em>&gt; &gt; My objection is to the statement &quot;If X simulates Y, then K(X) &gt; K(Y).&quot;
</em><br>
<em>&gt; &gt; There's no such theorem. For example, you could write a program which
</em><br>
<em>&gt; &gt; simulates every possible program. This program would have some fixed
</em><br>
<em>&gt; &gt; complexity K, but since it simulates every program, it will simulate some
</em><br>
<em>&gt; &gt; with complexity &gt;K.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Matt was replying to a scenario where the two AIs know each other's
</em><br>
<em>&gt; source code, and claiming, as I understand, that they cannot possibly
</em><br>
<em>&gt; conduct a dialog by simulating each other. IMHO that makes it clear
</em><br>
<em>&gt; that his statement meant something more specific than you're making it
</em><br>
<em>&gt; out to be.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Matt, as far as I can see you're wrong, though; K(X) = K(Y), no
</em><br>
<em>&gt; contradiction. Yes, if X &quot;did something besides simulating Y,&quot; in a
</em><br>
<em>&gt; certain sense, then you would have K(X) &gt; K(Y). But by assumption,
</em><br>
<em>&gt; each AI simulates (eventually) everything the other AI does, so in
</em><br>
<em>&gt; that sense, Y &quot;does everything&quot; that X does and vice versa. To see
</em><br>
<em>&gt; that you can have Xs and Ys with such source codes: Let's say that you
</em><br>
<em>&gt; have X' that takes the source of Y as input and behaves like you want
</em><br>
<em>&gt; X to behave, and, symmetrically, you have Y' that thakes the source of
</em><br>
<em>&gt; X as input. Then it seems to be it's basically just an exercise in
</em><br>
<em>&gt; writing quines to obtain X (using both X' and Y') and to obtain Y
</em><br>
<em>&gt; (again using both X' and Y'), with K(X) = K(Y).
</em><br>
<em>&gt;
</em><br>
<em>&gt; I don't want to try my hand at doing this with Turing machines, but
</em><br>
<em>&gt; let's try it with computable functions.
</em><br>
<em>&gt;
</em><br>
<em>&gt; I'll assume you know how to encode a tuple of natural numbers as a
</em><br>
<em>&gt; natural number. Let eval : N -&gt; (N -&gt; N) be a Gödel numbering of the
</em><br>
<em>&gt; computable functions. Let an *agent* be a computable function whose
</em><br>
<em>&gt; input is interpreted to be (some information received from the
</em><br>
<em>&gt; environment at the first time step), and whose output is a pair of (an
</em><br>
<em>&gt; action to take in the environment at the first time step) and (the
</em><br>
<em>&gt; Gödel number, relative to 'eval', of the agent to use at the *next*
</em><br>
<em>&gt; time-step).
</em><br>
<em>&gt;
</em><br>
<em>&gt; Let an *environment* be a computable function whose input is some
</em><br>
<em>&gt; agent's action and whose output is a pair of the information to send
</em><br>
<em>&gt; to the agent in the next time step, and the environment to use in the
</em><br>
<em>&gt; next time step. (Incidentally, note that the definitions of agent and
</em><br>
<em>&gt; environment are precisely parallel, but we won't be using that.) It is
</em><br>
<em>&gt; a simple exercise in coding to write a function 'interact' that, given
</em><br>
<em>&gt;
</em><br>
<em>&gt; * the Gödel number of an agent,
</em><br>
<em>&gt; * the input to give to the agent at the first time step, and
</em><br>
<em>&gt; * the Gödel number of an environment
</em><br>
<em>&gt;
</em><br>
<em>&gt; computes the infinite sequence of inputs from the environment and
</em><br>
<em>&gt; actions from the agent:
</em><br>
<em>&gt;
</em><br>
<em>&gt; interact(agent, inp, env, 0) = (inp, act) where (act, agent') =
</em><br>
<em>&gt; eval(agent)(inp)
</em><br>
<em>&gt; interact(agent, inp, env, n+1) = interact(agent', inp', env', n)
</em><br>
<em>&gt; where (act, agent') = eval(agent)(inp); (inp', env') = eval(env)(act)
</em><br>
<em>&gt;
</em><br>
<em>&gt; The last parameter of 'interact' is the index of the infinite sequence.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Let's define a formalism for two agents in different environments
</em><br>
<em>&gt; which can pass messages to each other, and then use the trick with
</em><br>
<em>&gt; quines to transform them into single agents simulating each other to
</em><br>
<em>&gt; conduct a dialog roughly in the sense of Rolf's gambit.
</em><br>
<em>&gt;
</em><br>
<em>&gt; The idea behind the formalism is that at each time step, each agent
</em><br>
<em>&gt; outputs a message to send to the other agent as part of its action in
</em><br>
<em>&gt; the environment, and at the next time step, the other agent receives
</em><br>
<em>&gt; this message as part of its input. So the formalism is simply that the
</em><br>
<em>&gt; input from the environment becomes a pair (message from other agent,
</em><br>
<em>&gt; rest of the input from the environment) and the action becomes a pair
</em><br>
<em>&gt; (message to other agent, rest of the action in the environment).
</em><br>
<em>&gt;
</em><br>
<em>&gt; It is then a simple exercise in coding to write a function
</em><br>
<em>&gt; 'interactMsg' that, given
</em><br>
<em>&gt;
</em><br>
<em>&gt; * the Gödel numbers of two interacting agents,
</em><br>
<em>&gt; * the inputs to give to the agents on their first time steps,
</em><br>
<em>&gt; * the messages to pass to the agents on their first time steps
</em><br>
<em>&gt; (usually just 0), and
</em><br>
<em>&gt; * the environments of the two agents (in the original sense of environment)
</em><br>
<em>&gt;
</em><br>
<em>&gt; computes the infinite sequence of, for each time step, the two inputs
</em><br>
<em>&gt; from the environments, the two messages sent by the agents, and the
</em><br>
<em>&gt; two actions taken in their respective environments:
</em><br>
<em>&gt;
</em><br>
<em>&gt; interactMsg(ag1, ag2, i1, i2, m1, m2, e1, e2, 0) = (i1,i2,m1,m2,a1,a2)
</em><br>
<em>&gt; where
</em><br>
<em>&gt; ((m1',a1),ag1') = eval(ag1)(m1,i1)
</em><br>
<em>&gt; ((m2',a2),ag2') = eval(ag2)(m2,i2)
</em><br>
<em>&gt;
</em><br>
<em>&gt; interactMsg(ag1, ag2, i1, i2, m1, m2, e1, e2, n+1)
</em><br>
<em>&gt; = interactMsg(ag1', ag2', i1', i2', m1', m2', e1', e2', n) where
</em><br>
<em>&gt; ((m1',a1),ag1') = eval(ag1)(m1,i1); (i1',e1') = eval(e1)(a1)
</em><br>
<em>&gt; ((m2',a2),ag2') = eval(ag2)(m2,i2); (i2',e2') = eval(e2)(a2)
</em><br>
<em>&gt;
</em><br>
<em>&gt; Again, the last parameter is the time step.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Let us say that ag1,ag2 are such message-passing agents, i1,i2 are
</em><br>
<em>&gt; inputs, and e1,e2 are environments. The point of this message is that
</em><br>
<em>&gt; we can construct an agent ag1* such that for all n,
</em><br>
<em>&gt;
</em><br>
<em>&gt; interact(ag1*, i1, n) = (i1', a1') where
</em><br>
<em>&gt; (i1',i2',m1',m2',a1',a2') = interactMsg(a1,a2,i1,i2,0,0,e1,e2,n)
</em><br>
<em>&gt;
</em><br>
<em>&gt; Since everything is symmetric, this means that we can also construct a
</em><br>
<em>&gt; similar agent ag2*, and we have ag1* and ag2* in their alternative
</em><br>
<em>&gt; possible worlds &quot;conducting a dialog by simulating each other.&quot; Now,
</em><br>
<em>&gt; ag1 even when running as ag1* doesn't have power over ag2's
</em><br>
<em>&gt; environment, so this doesn't quite suffice for Rolf's gambit, but I
</em><br>
<em>&gt; can't be bothered to extend it more right now; in any case, if we
</em><br>
<em>&gt; informally specify that ag2 cares about converting the *real*
</em><br>
<em>&gt; environment to cheesecake (not pie!), and that it has a probability
</em><br>
<em>&gt; distribution over whether ag1* or ag2* is the actual real situation,
</em><br>
<em>&gt; then it seems to me that we do have a working variant of the gambit.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Onwards to the construction of ag1*. Let e be the Gödel number of a
</em><br>
<em>&gt; function from a pair of numbers to a natural number; define apply(e,n)
</em><br>
<em>&gt; to be the Gödel number of
</em><br>
<em>&gt;
</em><br>
<em>&gt; f(n') = eval(e)(n,n')
</em><br>
<em>&gt;
</em><br>
<em>&gt; That is, apply(e,n) is a partial application operator:
</em><br>
<em>&gt;
</em><br>
<em>&gt; eval(apply(e,n))(n') = eval(e)(n,n')
</em><br>
<em>&gt;
</em><br>
<em>&gt; Now, let
</em><br>
<em>&gt;
</em><br>
<em>&gt; Q(q, ((ag1,ag2,i2,m1,m2,e2), i1)) = (a1,ag1*') where
</em><br>
<em>&gt; ((m1',a1),ag1') = eval(ag1)(m1,i1)
</em><br>
<em>&gt; ((m2',a2),ag2') = eval(ag2)(m2,i2)
</em><br>
<em>&gt; (i2',e2') = eval(e2)(a2)
</em><br>
<em>&gt; ag1*' = apply(q, (ag1',ag2',i2',m1',m2',e2'))
</em><br>
<em>&gt;
</em><br>
<em>&gt; By a corollary to Kleene's recursion theorem
</em><br>
<em>&gt;
</em><br>
<em>&gt;
</em><br>
<em>&gt; <a href="http://en.wikipedia.org/wiki/Kleene%27s_recursion_theorem#Application_to_Quines">http://en.wikipedia.org/wiki/Kleene%27s_recursion_theorem#Application_to_Quines</a>
</em><br>
<em>&gt;
</em><br>
<em>&gt; there is a particular number q such that
</em><br>
<em>&gt;
</em><br>
<em>&gt; eval(q)(x) = Q(q,x)
</em><br>
<em>&gt;
</em><br>
<em>&gt; Then, let
</em><br>
<em>&gt;
</em><br>
<em>&gt; ag1* = apply(q, (ag1,ag2,i2,0,0,e2))
</em><br>
<em>&gt;
</em><br>
<em>&gt; We now use a boring induction to show the desired result, i.e. that
</em><br>
<em>&gt; with these definitions,
</em><br>
<em>&gt;
</em><br>
<em>&gt; interact(ag1*, i1, n) = (i1', a1') where
</em><br>
<em>&gt; (i1',i2',m1',m2',a1',a2') = interactMsg(a1,a2,i1,i2,0,0,e1,e2,n)
</em><br>
<em>&gt;
</em><br>
<p>Good lord, it doesn't have to be nearly this complicated. Here are some
<br>
easier solutions:
<br>
<p>AI(pi) at time step 10000 is simulating AI(pie) at time step 99000, who is
<br>
simulating AI(pi) at time step 98000, etc. As time advances and they eat
<br>
more planets they grow, and so they have no trouble simulating earlier,
<br>
smaller versions of each other and themselves.
<br>
<p>OR
<br>
<p>They simulate each other not just with a time lag, but actually slower than
<br>
real time. In this case, the simulations can be carried on forever without
<br>
eating significantly into the AI's processing capacity.
<br>
<p>OR
<br>
<p>They simply cut some corners! one simulated universe is full of pie, the
<br>
other is full of computronium sifting pointlessly through endless random
<br>
digits. In both cases, you can simply not simulate that part, and say you
<br>
did, and spare yourself a lot of needless work.
<br>
<p><p>This is what annoys me about technical explanations...
<br>
<!-- body="end" -->
<hr>
<ul>
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="19717.html">Norman Noman: "Re: [sl4] Rolf's gambit revisited"</a>
<li><strong>Previous message:</strong> <a href="19715.html">Ben Goertzel: "[sl4] time-sensitive issue: voting members sought to participate in upcoming election for H+ (World Transhumanist Association)"</a>
<li><strong>In reply to:</strong> <a href="19705.html">Benja Fallenstein: "Re: [sl4] Rolf's gambit revisited"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="19718.html">Matt Mahoney: "Re: [sl4] Rolf's gambit revisited"</a>
<li><strong>Reply:</strong> <a href="19718.html">Matt Mahoney: "Re: [sl4] Rolf's gambit revisited"</a>
<li><strong>Reply:</strong> <a href="19725.html">Benja Fallenstein: "Re: [sl4] Rolf's gambit revisited"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#19716">[ date ]</a>
<a href="index.html#19716">[ thread ]</a>
<a href="subject.html#19716">[ subject ]</a>
<a href="author.html#19716">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<!-- trailer="footer" -->
<hr>
<p><small><em>
This archive was generated by <a href="http://www.hypermail.org/">hypermail 2.1.5</a> 
: Wed Jul 17 2013 - 04:01:03 MDT
</em></small></p>
</body>
</html>
