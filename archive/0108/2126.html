<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta name="generator" content="hypermail 2.1.5, see http://www.hypermail.org/">
<title>SL4: Re: Learning to intelligently self-modify...</title>
<meta name="Author" content="Durant Schoon (durant@ilm.com)">
<meta name="Subject" content="Re: Learning to intelligently self-modify...">
<meta name="Date" content="2001-08-14">
<style type="text/css">
body {color: black; background: #ffffff}
h1.center {text-align: center}
div.center {text-align: center}
</style>
</head>
<body>
<h1>Re: Learning to intelligently self-modify...</h1>
<!-- received="Tue Aug 14 17:35:50 2001" -->
<!-- isoreceived="20010814233550" -->
<!-- sent="Tue, 14 Aug 2001 13:01:24 -0700 (PDT)" -->
<!-- isosent="20010814200124" -->
<!-- name="Durant Schoon" -->
<!-- email="durant@ilm.com" -->
<!-- subject="Re: Learning to intelligently self-modify..." -->
<!-- id="durant-1010814130124.A07139406@sleeper" -->
<!-- inreplyto="NDBBIBGFAPPPBODIPJMMAEBFGEAA.ben@webmind.com" -->
<!-- expires="-1" -->
<p>
<strong>From:</strong> Durant Schoon (<a href="mailto:durant@ilm.com?Subject=Re:%20Learning%20to%20intelligently%20self-modify..."><em>durant@ilm.com</em></a>)<br>
<strong>Date:</strong> Tue Aug 14 2001 - 14:01:24 MDT
</p>
<!-- next="start" -->
<ul>
<li><strong>Next message:</strong> <a href="2127.html">Christian L.: "Re: Post-Singularity Trade (was: Sysops, volition, and opting out)"</a>
<li><strong>Previous message:</strong> <a href="2125.html">James Higgins: "Re: Post-Singularity Trade  (was: Sysops, volition, and opting out)"</a>
<li><strong>In reply to:</strong> <a href="2111.html">Ben Goertzel: "Learning to intelligently self-modify..."</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#2126">[ date ]</a>
<a href="index.html#2126">[ thread ]</a>
<a href="subject.html#2126">[ subject ]</a>
<a href="author.html#2126">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<hr>
<!-- body="start" -->
<p>
<em>&gt; From: &quot;Ben Goertzel&quot; &lt;<a href="mailto:ben@webmind.com?Subject=Re:%20Learning%20to%20intelligently%20self-modify...">ben@webmind.com</a>&gt;
</em><br>
<p><em>&gt; Getting from pseudocode to program code is a matter of &quot;procedural
</em><br>
<em>&gt; refinement&quot;, one aspect of procedural cognition -- and this can be very hard
</em><br>
<em>&gt; thinking, of course, involving invocation of relevant experiences, formal
</em><br>
<em>&gt; knowledge of algorithms, knowledge of the operating conditions of the
</em><br>
<em>&gt; program, etc...
</em><br>
<p>Ah, this is nice! It sounds like that powerful term someone brought up
<br>
before: &quot;intentional programming&quot;, where the intention (pseudocode) is
<br>
then brought to fruition (program code) by some process.
<br>
<p><em>&gt; In Webmind terms, the pseudocode level basically consists of a node-and-link
</em><br>
<em>&gt; representation of schema *without* any of the schema-specific bells and
</em><br>
<em>&gt; whistles (like token-passing to indicate that one procedure can't start
</em><br>
<em>&gt; until another has finished, etc.).   The program code level consists of a
</em><br>
<em>&gt; fully-specified node-and-link representation of a schema.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; *IF* one had a procedural refinement approach that worked -- i.e. a set of
</em><br>
<em>&gt; mind-processes that take in pseudocode and spit out program code (in the WM
</em><br>
<em>&gt; case, the program code is a fully specified schema) -- then one would be
</em><br>
<em>&gt; well-positioned to tune the system to learn new pseudocode to approach new
</em><br>
<em>&gt; problems.  Because for each new candidate bit of pseudocode, the system
</em><br>
<em>&gt; would know how to create a new program code embodying the ideas outlines in
</em><br>
<em>&gt; the pseudocode, thus being able to test the pragmatic validity of the
</em><br>
<em>&gt; pseudocode.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; If we're to use the human case as an analogy, then procedural refinement is
</em><br>
<em>&gt; going to have to be learned or minimally parameter-tuned by the system via
</em><br>
<em>&gt; experimentation in a simple action domain (simpler than the domain of
</em><br>
<em>&gt; modifying its own source code for example).  Here is where all the classic
</em><br>
<em>&gt; AI problems of playing games, moving blocks around, etc., become potentially
</em><br>
<em>&gt; interesting.  If a system can't translate pseudocode into program code in
</em><br>
<em>&gt; simple contexts like this, having it do so in the context of modifying its
</em><br>
<em>&gt; own behavioral schema is obviously pretty hopeless...
</em><br>
<p>True. Though, to be general (not WM-ish here), goals need to be
<br>
translated to program code.
<br>
<p><em>&gt; The difference between these thoughts and our past WM work on schema
</em><br>
<em>&gt; learning is basically the strictness of the breakdown into two levels.
</em><br>
<em>&gt; Before we had
</em><br>
<em>&gt; 
</em><br>
<em>&gt; --&gt; SchemaConceptNodes, an abstract level for reasoning about procedures
</em><br>
<em>&gt; --&gt; SchemaNodes, for actually carrying out procedures
</em><br>
<em>&gt; 
</em><br>
<em>&gt; and we actually had relations between SCN's and SN's on different levels of
</em><br>
<em>&gt; granularity, but we hadn't formalized a distinction between two granularity
</em><br>
<em>&gt; levels of schema relationships (here posited as pseudocode-ish and
</em><br>
<em>&gt; program-code-ish)
</em><br>
<em>&gt; 
</em><br>
<em>&gt; This is actually a point that was raised many times in past (WM-internal)
</em><br>
<em>&gt; discussions on schema learning, in the guise of the need for a &quot;plan
</em><br>
<em>&gt; optimization&quot; phase.  But the idea there, I think, was that the first phase
</em><br>
<em>&gt; of schema learning would result in an inefficient but detailed program, to
</em><br>
<em>&gt; be refined into an efficient one.  what I'm suggesting here is that the
</em><br>
<em>&gt; first phase actually doesn't result in the learning of a detailed program at
</em><br>
<em>&gt; all, but just a pseudocode sketch.
</em><br>
<p>It might be important to state here *why* you want to distinguish
<br>
these two levels. I'd venture that if this is a good idea, it is good
<br>
because reasoning about pseudocode is easier than reasoning about
<br>
program code. Ok, now it's my turn to make an analogy:
<br>
<p>Say we have two games SKETCH and DETAILED. The SKETCH board is a 16x16
<br>
grid and has ten pieces. DETAILED is a 1000x1000 board and has 300
<br>
pieces(*). Moves in SKETCH are equivalent to a number of moves in
<br>
DETAILED. It turns out that the DETAILED game can be played as moves
<br>
in SKETCH (SKETCH moves are translated to DETAILED moves). The mapping
<br>
is not 1 to 1, that is moves in SKETCH can be one of several sequences
<br>
of moves in DETAILED, the final game play, however, specifically score
<br>
is the same.
<br>
<p>The game we want to play and win is DETAILED, but by playing SKETCH,
<br>
can we actually be better players at DETAILED. This analogy is
<br>
hopefully a useful and obvious one by now where:
<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SKETCH   = pseudo code
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DETAILED = program code
<br>
<p>The simplistic, first thought is to conjecture that:
<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Learn to play SKETCH well and you can win at DETAILED. 
<br>
<p>This is our general guiding principle, but we all know that the devil
<br>
is in the details. Let's begin,
<br>
<p>Some heuristics for writing good code(**) (These rules of thumb apply
<br>
both to SKETCH as well as to DETAILED):
<br>
<p>GENERAL(***)
<br>
-------
<br>
* Reliability
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If two moves satisfy the same goal all the time they are
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equally reliable. 
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If one move satisfies a same goal more often than another
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move, the first move is more reliable.
<br>
<p>* Reuse / Modularity
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reusable, modular sets of moves are better.
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Why? This lowers the number of techniques which have to be
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remembered. 
<br>
<p>* Simplicity
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cognition on simpler moves is faster.
<br>
<p>The above list can be used as guides for strategizing in both SKETCH
<br>
and DETAILED. Once a game plan has been found in SKETCH following
<br>
these heuristics, there may be several functionally equivalent
<br>
move-sets(*4) in DETAILED. The same heuristics can be applied when
<br>
choosing which move-sets to use in DETAILED.
<br>
<p>We need to stop about here to undo a faulty, but thus-far useful,
<br>
assumption. We have not considered that in order to choose our moves
<br>
in SKETCH, we will sometimes need to acknowledge that strategy in
<br>
DETAILED does in fact need to influence our decisions in SKETCH. 
<br>
<p>I'm thinking of effieciency here. For example, when programming, we
<br>
can recognize that some low level data structures and techniques are
<br>
far more effiecient than others. When we diverge from our guiding
<br>
principle is when we have a set of moves that look good optimal
<br>
SKETCH, but there are actually better moves because some corresponding
<br>
moves in DETAILED will get us much farther.
<br>
<p>So what we really need to know is:
<br>
<p>&nbsp;&nbsp;&nbsp;How to play SKETCH well.
<br>
&nbsp;&nbsp;&nbsp;Know when playing SKETCH isn't enough and we need optimize in
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DETAILED. 
<br>
<p>All of our learning algorithms come in handy when we have to balance
<br>
these two well. We want to spend most of our time in SKETCH, because
<br>
it's more effiecient. But we can't all the time, so we not only have
<br>
to have some way of switching to good moves in DETAILED, we need to
<br>
figure out a good way of know *when* to switch.
<br>
<p><p>Lastly, it should be remembered, that there are always two goals major
<br>
being satisfied at all times:
<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) Specific: to solve the problem at hand
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) General: to learn how to solve problems better later.
<br>
<p>1) might use simple scoring techniques to choose one strategy over
<br>
another, but because of 2) complex knowlege relating to the why's
<br>
and how's of one strategy vs. another need to be analyzed and stored
<br>
for quick retrieval in the future.
<br>
<p>Hey, I'm hungry. It's lunchtime in California...
<br>
<p><p>----------
<br>
<p>(*) The actual numbers do not matter.
<br>
<p>(**) I'll freely intermix the coding example with the game play
<br>
analogy. A &quot;move&quot; can mean a series of &quot;moves&quot;, ie. a series of steps
<br>
in a program or pseudocode.
<br>
<p>(***) 
<br>
FOR US HUMANS
<br>
-------------
<br>
* Familiarity (Recognizable Patterns for Multiprogrammer environments)
<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This just recognizes that a driving force in coding among
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;humans is the constraint that more than one human programmer
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;understand a section of code quickly and thoroughly. 
<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Think recent trends emphasizing Patterns and eXtreme
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming principles.
<br>
&nbsp;
<br>
(*4) &quot;move-sets&quot; - Just a convenience term for a set of moves. It
<br>
might be one move, it might be many. 
<br>
<p><p><pre>
--
Durant Schoon
</pre>
<!-- body="end" -->
<hr>
<ul>
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="2127.html">Christian L.: "Re: Post-Singularity Trade (was: Sysops, volition, and opting out)"</a>
<li><strong>Previous message:</strong> <a href="2125.html">James Higgins: "Re: Post-Singularity Trade  (was: Sysops, volition, and opting out)"</a>
<li><strong>In reply to:</strong> <a href="2111.html">Ben Goertzel: "Learning to intelligently self-modify..."</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#2126">[ date ]</a>
<a href="index.html#2126">[ thread ]</a>
<a href="subject.html#2126">[ subject ]</a>
<a href="author.html#2126">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<!-- trailer="footer" -->
<hr>
<p><small><em>
This archive was generated by <a href="http://www.hypermail.org/">hypermail 2.1.5</a> 
: Wed Jul 17 2013 - 04:00:37 MDT
</em></small></p>
</body>
</html>
