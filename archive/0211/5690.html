<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hypermail 2.1.5, see http://www.hypermail.org/">
<title>SL4: RE: early AGI apps</title>
<meta name="Author" content="Ben Goertzel (ben@goertzel.org)">
<meta name="Subject" content="RE: early AGI apps">
<meta name="Date" content="2002-11-09">
<style type="text/css">
body {color: black; background: #ffffff}
h1.center {text-align: center}
div.center {text-align: center}
</style>
</head>
<body>
<h1>RE: early AGI apps</h1>
<!-- received="Sat Nov  9 09:46:35 2002" -->
<!-- isoreceived="20021109164635" -->
<!-- sent="Sat, 9 Nov 2002 11:46:04 -0500" -->
<!-- isosent="20021109164604" -->
<!-- name="Ben Goertzel" -->
<!-- email="ben@goertzel.org" -->
<!-- subject="RE: early AGI apps" -->
<!-- id="LAEGJLOGJIOELPNIOOAJIEPPDMAA.ben@goertzel.org" -->
<!-- charset="US-ASCII" -->
<!-- inreplyto="2620584679.20021108235254@earthlink.net" -->
<!-- expires="-1" -->
<p>
<strong>From:</strong> Ben Goertzel (<a href="mailto:ben@goertzel.org?Subject=RE:%20early%20AGI%20apps"><em>ben@goertzel.org</em></a>)<br>
<strong>Date:</strong> Sat Nov 09 2002 - 09:46:04 MST
</p>
<!-- next="start" -->
<ul>
<li><strong>Next message:</strong> <a href="5691.html">Ben Goertzel: "RE: early AGI apps"</a>
<li><strong>Previous message:</strong> <a href="5689.html">Ben Goertzel: "RE: early AGI apps"</a>
<li><strong>In reply to:</strong> <a href="5683.html">Cliff Stabbert: "re: early AGI apps"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="5684.html">Reason: "RE: early AGI apps"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#5690">[ date ]</a>
<a href="index.html#5690">[ thread ]</a>
<a href="subject.html#5690">[ subject ]</a>
<a href="author.html#5690">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<hr>
<!-- body="start" -->
<p>
Cliff,
<br>
<p>Regarding your idea for an AGI application...
<br>
<p>I think it's an interesting one, but a very hard one, suitable only for
<br>
AGI's at the near-human stage of general intelligence.  Understanding the
<br>
pragmatics of what humans are trying to do at their PC's, is a tough
<br>
problem, requiring sophisticated modeling of human psychology....
<br>
<p>There's only one way I can envision your product being doable in the short
<br>
term, and that's if it were installed on a HUGE number of computers all at
<br>
once, so that there was a vast amount of statistical data from which it
<br>
could make inferences about what a given user might be trying to do.  In
<br>
other words, maybe it could work in the short term if M$ were to integrate
<br>
it into Windows ;-)
<br>
<p>I think that there's a limited subset of your proposal that is more feasible
<br>
in the very short term though, and that's AI-driven system administration.
<br>
Stephanie Forrest and her students at UNM have done some interesting work on
<br>
&quot;computer immune systems&quot;, which are simple statistical narrow-AI-ish
<br>
systems for intrusion detection.  But there's a huge amount more that can be
<br>
done along these lines.  The initial market would be companies owning server
<br>
farms, which are very complex to administer, rather than individual PC
<br>
owners....
<br>
<p>-- Ben G
<br>
<p><p><em>&gt; -----Original Message-----
</em><br>
<em>&gt; From: <a href="mailto:owner-sl4@sl4.org?Subject=RE:%20early%20AGI%20apps">owner-sl4@sl4.org</a> [mailto:<a href="mailto:owner-sl4@sl4.org?Subject=RE:%20early%20AGI%20apps">owner-sl4@sl4.org</a>]On Behalf Of Cliff
</em><br>
<em>&gt; Stabbert
</em><br>
<em>&gt; Sent: Friday, November 08, 2002 11:53 PM
</em><br>
<em>&gt; To: <a href="mailto:sl4@sl4.org?Subject=RE:%20early%20AGI%20apps">sl4@sl4.org</a>
</em><br>
<em>&gt; Subject: re: early AGI apps
</em><br>
<em>&gt;
</em><br>
<em>&gt;
</em><br>
<em>&gt; I wrote:
</em><br>
<em>&gt; CS&gt; I think the Novamente approach -- more narrowly focused commercial
</em><br>
<em>&gt; CS&gt; efforts -- are a very good approach to funding currently.  I do have
</em><br>
<em>&gt; CS&gt; a long-simmering but vague-in-details idea for some AI tech that
</em><br>
<em>&gt; CS&gt; Novamente at its current stage may or may not be suited to, which
</em><br>
<em>&gt; CS&gt; if implemented as a software package could be quite popular.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Ben Goertzel:
</em><br>
<em>&gt; BG&gt; Well, feel free to voice the details, either on the list or
</em><br>
<em>&gt; via private
</em><br>
<em>&gt; BG&gt; e-mail, <a href="mailto:ben@goertzel.org?Subject=RE:%20early%20AGI%20apps">ben@goertzel.org</a> ;)
</em><br>
<em>&gt;
</em><br>
<em>&gt; Peter Voss:
</em><br>
<em>&gt; &gt; I'm interested in any and all potential early applications for
</em><br>
<em>&gt; AGI - both to
</em><br>
<em>&gt; &gt; evaluate the performance of our a2i2 system, and for possible
</em><br>
<em>&gt; &gt; implementation.
</em><br>
<em>&gt;
</em><br>
<em>&gt; I don't have much time at the moment to sketch this in greater detail,
</em><br>
<em>&gt; and my own limited notes on this are at the time unavailable.  So what
</em><br>
<em>&gt; follows is *very* vague, brief and blue-sky...but it may spark some
</em><br>
<em>&gt; ideas.
</em><br>
<em>&gt;
</em><br>
<em>&gt; The main thrust is the use of AI in GUIs.  There are two main aspects
</em><br>
<em>&gt; to that -- modeling the computer and modeling the user -- as well as
</em><br>
<em>&gt; some other features.  As a product, I envision something that sits &quot;on
</em><br>
<em>&gt; top&quot; of the OS, or encapsulates it, and is always the &quot;outermost&quot;
</em><br>
<em>&gt; control the user can speak to -- the ultimate arbiter, the
</em><br>
<em>&gt; presidential hotline, and where the user communicates *about* what the
</em><br>
<em>&gt; computer does.  (Another, somewhat less ambitious, implementation
</em><br>
<em>&gt; would be specific to and sit on top of a software package such as
</em><br>
<em>&gt; Microsoft Office).
</em><br>
<em>&gt;
</em><br>
<em>&gt; -------------
</em><br>
<em>&gt;
</em><br>
<em>&gt; I'm sure all of us have run into problems like the following: I was
</em><br>
<em>&gt; installing a piece of software under Windows.  I have my PC set up
</em><br>
<em>&gt; with all apps on E:, so I chose E: as the install drive.  It wouldn't
</em><br>
<em>&gt; let me proceed because, it said, the E: drive was full.  I checked
</em><br>
<em>&gt; under Explorer -- and as I thought, I had plenty of space.
</em><br>
<em>&gt;
</em><br>
<em>&gt; So what was going on?  I'm not certain -- it may have been that the
</em><br>
<em>&gt; installation program was looking at total minus used space and going
</em><br>
<em>&gt; by the 2GB value for total space (this was under Win95); it may have
</em><br>
<em>&gt; been using variables that were too small and getting overflow...it may
</em><br>
<em>&gt; have been any number of glitches.
</em><br>
<em>&gt;
</em><br>
<em>&gt; But it got me thinking -- we have two different programs (the
</em><br>
<em>&gt; installer and Explorer) telling me two different things.  We have an
</em><br>
<em>&gt; &quot;out of space&quot; dialog box that some programmer went to the trouble of
</em><br>
<em>&gt; building, and the out-of-space check they coded for it...
</em><br>
<em>&gt;
</em><br>
<em>&gt; When you work on a modern GUI, it's really in a sense like you're
</em><br>
<em>&gt; having a dialogue. You tell it to do things, and it comes back with
</em><br>
<em>&gt; &quot;dialog boxes&quot; (&quot;disk too full&quot;, etc.).
</em><br>
<em>&gt;
</em><br>
<em>&gt; The problem is that you are having a dialogue with a schizophrenic
</em><br>
<em>&gt; amnesiac, and what is more, one who communicates in a very inflexible,
</em><br>
<em>&gt; rigid, repetitive way.
</em><br>
<em>&gt;
</em><br>
<em>&gt; As a user, I want a single, coherent, consistent conversation that
</em><br>
<em>&gt; builds -- from question to question and day to day. A conversation
</em><br>
<em>&gt; that makes sense.
</em><br>
<em>&gt;
</em><br>
<em>&gt; -------------
</em><br>
<em>&gt;
</em><br>
<em>&gt; In essence what I want as a user is that the computer &quot;understands&quot;
</em><br>
<em>&gt; what it is telling me.  Well, what does that mean?  That it must have
</em><br>
<em>&gt; some internal representation of itself, that symbols such as &quot;hard
</em><br>
<em>&gt; drive&quot; and &quot;free space&quot; must be not just strings of characters, but
</em><br>
<em>&gt; have some semantic *value* -- some *referent*.
</em><br>
<em>&gt;
</em><br>
<em>&gt; I.e., the software should have an internal model of the computer in
</em><br>
<em>&gt; which terms such as the above are meaningfully linked to actual values
</em><br>
<em>&gt; from that model.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Such a model, with some associated pseudo-natural-language processing,
</em><br>
<em>&gt; may be the &quot;simpler&quot; aspect of the software -- perhaps amenable to
</em><br>
<em>&gt; established technologies (DBs, natural query languages, expert
</em><br>
<em>&gt; systems, etc.).
</em><br>
<em>&gt;
</em><br>
<em>&gt; -------------
</em><br>
<em>&gt;
</em><br>
<em>&gt; When I tell the computer to save my file and the disk *is* full, it
</em><br>
<em>&gt; should come up with a more meaningful set of choices - it should have
</em><br>
<em>&gt; some basic understanding of why I want to save a file and e.g. offer
</em><br>
<em>&gt; me - do you want to clear some space or save to D: instead?
</em><br>
<em>&gt;
</em><br>
<em>&gt; Now, I have seen the above -- a dialog box asking me whether I want to
</em><br>
<em>&gt; clear space -- but it, again, was something some programmer separately
</em><br>
<em>&gt; designed and built code for.
</em><br>
<em>&gt;
</em><br>
<em>&gt; As a user, I want the computer to &quot;know&quot; that I want to save files,
</em><br>
<em>&gt; that if space is unavailable in one place I may want to save it
</em><br>
<em>&gt; elsewhere, or free space up.
</em><br>
<em>&gt;
</em><br>
<em>&gt; More fundamentally, I want to be able to teach it such things.
</em><br>
<em>&gt;
</em><br>
<em>&gt; -------------
</em><br>
<em>&gt;
</em><br>
<em>&gt; This implies the software needs to have an internal evolvable model of
</em><br>
<em>&gt; me, the user, as well.
</em><br>
<em>&gt;
</em><br>
<em>&gt; In the context of Microsoft Office, it would have some ideas of &quot;what
</em><br>
<em>&gt; I do&quot; (create new documents and edit existing ones, type and format
</em><br>
<em>&gt; stuff, print them, save them, file them, search them).  It should
</em><br>
<em>&gt; learn and suggest things on its own (create &quot;wizards&quot; on the fly --
</em><br>
<em>&gt; I type &quot;Dear George&quot; and it pops up with &quot;another letter to George,
</em><br>
<em>&gt; 'ey? Usual headings? File under 'Presidential correspondence'?&quot;)
</em><br>
<em>&gt;
</em><br>
<em>&gt; The model should evolve both under internal (user-confirmed) guesses
</em><br>
<em>&gt; and under user direction.  The software should always have available
</em><br>
<em>&gt; -- no matter what the user is doing -- a way for the user to interrupt
</em><br>
<em>&gt; and tell it to &quot;go meta&quot;.  By this I mean a way for the user to tell
</em><br>
<em>&gt; the software &quot;Now watch what I'm doing...whenever I do X, I want you
</em><br>
<em>&gt; to do Y and Z.&quot; or &quot;See that dialog that popped up?  Always click &quot;No&quot;
</em><br>
<em>&gt; on that one.&quot;
</em><br>
<em>&gt;
</em><br>
<em>&gt; Here's where the model gets more complex, because it needs to deal
</em><br>
<em>&gt; with analogies.  &quot;See how I'm taking each of the sentences from this
</em><br>
<em>&gt; paragraph and making them bullet points?  Do it for the rest of the
</em><br>
<em>&gt; paragraph.&quot; is relatively simple.  &quot;Do the same thing to this line
</em><br>
<em>&gt; chart.&quot; is more complex (what is &quot;the same thing&quot;?  Does each series
</em><br>
<em>&gt; (line) get split into its own chart?  Each year?).  This is also the
</em><br>
<em>&gt; point in the model where an ongoing dialogue becomes most important --
</em><br>
<em>&gt; being able to correct the assumptions and guesses the software makes,
</em><br>
<em>&gt; such corrections getting folded back into the model.
</em><br>
<em>&gt;
</em><br>
<em>&gt; -------------
</em><br>
<em>&gt;
</em><br>
<em>&gt; The language used to describe the internal structures of the computer
</em><br>
<em>&gt; and its software, actions associated with them, etc. should allow for
</em><br>
<em>&gt; sharing between users.  In other words, once one user has &quot;told&quot; the
</em><br>
<em>&gt; system about what PhotoShop does (via interactive querying by the
</em><br>
<em>&gt; software, details too long to go into), others wouldn't need to.
</em><br>
<em>&gt;
</em><br>
<em>&gt; -------------
</em><br>
<em>&gt;
</em><br>
<em>&gt; So, vague and scatter-shot.  There's a lot left out of the above and
</em><br>
<em>&gt; when I can dig up all my notes and have the time, I might put together a
</em><br>
<em>&gt; more coherent and detailed presentation of this; the AGI list is
</em><br>
<em>&gt; probably a more suitable venue.
</em><br>
<em>&gt;
</em><br>
<em>&gt; The reason I see this as a viable application for (early) AGI is
</em><br>
<em>&gt; because on the one hand it requires limited, quantifiable, shareable
</em><br>
<em>&gt; knowledge (domain expertise about software combined with the ability
</em><br>
<em>&gt; to intercept both user events and OS API calls) and on the other,
</em><br>
<em>&gt; provides an &quot;evolution-driving&quot; environment: the user's requirements.
</em><br>
<em>&gt;
</em><br>
<em>&gt; There is IMO a widespread need for such tech in user interfaces, thus
</em><br>
<em>&gt; plenty of people who would want to use it.  And possibly, if this or
</em><br>
<em>&gt; some variant on it was structured in the right way (perhaps dealing
</em><br>
<em>&gt; with the browsing experience, say), a huge number of users could be
</em><br>
<em>&gt; leveraged to drastically accelerate the evolution of the software.
</em><br>
<em>&gt;
</em><br>
<em>&gt;
</em><br>
<em>&gt; --
</em><br>
<em>&gt; Cliff
</em><br>
<em>&gt;
</em><br>
<!-- body="end" -->
<hr>
<ul>
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="5691.html">Ben Goertzel: "RE: early AGI apps"</a>
<li><strong>Previous message:</strong> <a href="5689.html">Ben Goertzel: "RE: early AGI apps"</a>
<li><strong>In reply to:</strong> <a href="5683.html">Cliff Stabbert: "re: early AGI apps"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="5684.html">Reason: "RE: early AGI apps"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#5690">[ date ]</a>
<a href="index.html#5690">[ thread ]</a>
<a href="subject.html#5690">[ subject ]</a>
<a href="author.html#5690">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<!-- trailer="footer" -->
<hr>
<p><small><em>
This archive was generated by <a href="http://www.hypermail.org/">hypermail 2.1.5</a> 
: Wed Jul 17 2013 - 04:00:41 MDT
</em></small></p>
</body>
</html>
