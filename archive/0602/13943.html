<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="generator" content="hypermail 2.1.5, see http://www.hypermail.org/">
<title>SL4: Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]</title>
<meta name="Author" content="Charles D Hixson (charleshixsn@earthlink.net)">
<meta name="Subject" content="Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]">
<meta name="Date" content="2006-02-01">
<style type="text/css">
body {color: black; background: #ffffff}
h1.center {text-align: center}
div.center {text-align: center}
</style>
</head>
<body>
<h1>Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]</h1>
<!-- received="Wed Feb  1 21:59:52 2006" -->
<!-- isoreceived="20060202045952" -->
<!-- sent="Thu, 2 Feb 2006 04:59:41 +0000" -->
<!-- isosent="20060202045941" -->
<!-- name="Charles D Hixson" -->
<!-- email="charleshixsn@earthlink.net" -->
<!-- subject="Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]" -->
<!-- id="200602020459.41774.charleshixsn@earthlink.net" -->
<!-- charset="iso-8859-1" -->
<!-- inreplyto="3642969c0602010757p7be252dbyf7f24e620f6c870a@mail.gmail.com" -->
<!-- expires="-1" -->
<p>
<strong>From:</strong> Charles D Hixson (<a href="mailto:charleshixsn@earthlink.net?Subject=Re:%20Syllabus%20for%20Seed%20Developer%20Qualifications%20[WAS%20Re:%20Some%20considerations%20about%20AGI]"><em>charleshixsn@earthlink.net</em></a>)<br>
<strong>Date:</strong> Wed Feb 01 2006 - 21:59:41 MST
</p>
<!-- next="start" -->
<ul>
<li><strong>Next message:</strong> <a href="13944.html">Patrick Crenshaw: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<li><strong>Previous message:</strong> <a href="13942.html">Richard Loosemore: "Languages for AGI  [WAS Re: Syllabus for Seed Developer Qualifications...]"</a>
<li><strong>In reply to:</strong> <a href="13939.html">Kevin Osborne: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="13944.html">Patrick Crenshaw: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<li><strong>Reply:</strong> <a href="13944.html">Patrick Crenshaw: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<li><strong>Reply:</strong> <a href="13946.html">Kevin Osborne: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#13943">[ date ]</a>
<a href="index.html#13943">[ thread ]</a>
<a href="subject.html#13943">[ subject ]</a>
<a href="author.html#13943">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<hr>
<!-- body="start" -->
<p>
On Wednesday 01 February 2006 03:57 pm, Kevin Osborne wrote:
<br>
<em>&gt; without putting a fire under yet another religious programming
</em><br>
<em>&gt; language 'discussion' of attrition, I have what for me is an important
</em><br>
<em>&gt; question in regards to AGI development and seed developer syllabus:
</em><br>
<em>&gt;
</em><br>
<em>&gt; what programming language are we going to code an AGI with?
</em><br>
<em>&gt;
</em><br>
<em>&gt; when answering this question I probably want to dismiss convoluted
</em><br>
<em>&gt; combinations of systems, specialist languages/compilers that may
</em><br>
<em>&gt; (already?) be developed for AGI purposes and focus on:
</em><br>
<em>&gt;
</em><br>
<em>&gt; what's the best language to develop the AGI workhorse code in?
</em><br>
<em>&gt;
</em><br>
<em>&gt; 'workhorse' here means the code that will bridge the gap from the
</em><br>
<em>&gt; not-so 'intelligent' systems we have now and be able to bootstrap a
</em><br>
<em>&gt; higher semantic-language/instruction-set that will be part of the
</em><br>
<em>&gt; first steps towards an AGI.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Here's a hopefully not-too-biased critique-that-invites-critique of
</em><br>
<em>&gt; some of the choices as they stand:
</em><br>
<em>&gt;
</em><br>
<em>&gt; C: I'm separating this from C++ as, well, most of the crack C
</em><br>
<em>&gt; programmers I've worked with view C++ as some kind of leperous cousin;
</em><br>
<em>&gt; they're able to make a host of criticisms of C++ in contrast to C but
</em><br>
<em>&gt; I'm not one to repeat them succinctly I think. In summary;
</em><br>
<em>&gt; positives:
</em><br>
<em>&gt; - it's the fastest; without question. It also runs on every board on
</em><br>
<em>&gt; the planet. There are a host of _great_ tools and compilers from the
</em><br>
<em>&gt; likes of GCC, Sun, Intel, IBM, HP etc. If you want to write your own
</em><br>
<em>&gt; OS kernel then you'll be doing it in C.
</em><br>
<em>&gt; - the #1 choice for RTOS. if you want it to run real-time, it'll be in
</em><br>
<em>&gt; C. I''ve personally had exposure to the VxWorks and Nucleus hard
</em><br>
<em>&gt; real-time systems and a soft real-time Linux (Monta Vista). Even if
</em><br>
<em>&gt; don't end up with
</em><br>
<em>&gt; kernel=observer/ego/consciousness/insert-your-term-here, going
</em><br>
<em>&gt; real-time seems to be an intuitive requirement for replicating a range
</em><br>
<em>&gt; of faculties. That said, real-time code is very limited to what it can
</em><br>
<em>&gt; do; it runs out of puff pretty quickly when climbing the OSI stack.
</em><br>
<em>&gt; - Macros are a great language feature, and can provide some of the
</em><br>
<em>&gt; extensibility and run-time switching needed.
</em><br>
<em>&gt; - great debugging tools and lint collectors like Purify that can
</em><br>
<em>&gt; pretty much guarantee against a number of errors like memory leaks and
</em><br>
<em>&gt; overwrites
</em><br>
<em>&gt; negatives:
</em><br>
<em>&gt; - plumbing code. it just plain sucks to have to call memset, malloc
</em><br>
<em>&gt; and free everywhere. #IFDEF may be damn useful but for me is ugly as
</em><br>
<em>&gt; hell
</em><br>
<em>&gt; - complexity/productivity. add all the plumbing code in; the need to
</em><br>
<em>&gt; track and free all your resources; macros that obfuscate recursive &amp;
</em><br>
<em>&gt; often cyclic function calls to n levels; the need to dick with your
</em><br>
<em>&gt; defines both in the code and in the compiler, and the flag mess that
</em><br>
<em>&gt; ensues when you are linking against every man and his dll and you end
</em><br>
<em>&gt; up with a language great for low-level tweaking of the cpu instruction
</em><br>
<em>&gt; set and a morass once it scales that eats huge amounts of programmer
</em><br>
<em>&gt; time dicking with the maintenance of flags, variables and
</em><br>
<em>&gt; linker/compiler bleats. this inevitibly sucks large amounts of time
</em><br>
<em>&gt; away from higher-level functional work, especially during integration
</em><br>
<em>&gt; with other people's code. I'd posit it as a given that we are going to
</em><br>
<em>&gt; have to write more higher-level functional code than for any other
</em><br>
<em>&gt; project ever attempted. To code the capabilities and faculties of
</em><br>
<em>&gt; smart human is going to be a ridiculously huge endeavour. And once our
</em><br>
<em>&gt; boy is smart enough he'll be rewriting himself bigger and bigger while
</em><br>
<em>&gt; rewriting our code smaller and smaller. we just need to write
</em><br>
<em>&gt; something big enough so that he has the capability to do so.
</em><br>
<em>&gt;
</em><br>
<em>&gt;
</em><br>
<em>&gt; C++: the current language of choice for all large critical systems
</em><br>
<em>&gt; worldwide. The OSes are written in C, but the apps are in C++. When
</em><br>
<em>&gt; your plane lands, it's C++; when the latest NASA space-gadget bleeps,
</em><br>
<em>&gt; it's C++. The vast majority of apps that run global infrastructure are
</em><br>
<em>&gt; in C++.
</em><br>
<em>&gt;
</em><br>
<em>&gt; positives:
</em><br>
<em>&gt; - first things first; every VM and interpreter of note for the
</em><br>
<em>&gt; bytecode/interpreted languages is written in C++.  A Java programmer
</em><br>
<em>&gt; bitching about C++ is like a hand bitching about it's forearm. If you
</em><br>
<em>&gt; want to hack your own special JIT or JVM, you'll need to be doing it
</em><br>
<em>&gt; in C++
</em><br>
<em>&gt; - Most of the RTOS vendors provide C++ APIs; so real-time application
</em><br>
<em>&gt; development is available (for a cost)
</em><br>
<em>&gt; - There's a larger body of support libraries available than for C when
</em><br>
<em>&gt; it comes to higher-level functions; the STL is a great example
</em><br>
<em>&gt;
</em><br>
<em>&gt; negatives:
</em><br>
<em>&gt; - as noted in one of the posts above, the toolset is awful in
</em><br>
<em>&gt; comparison. g++ is gcc's ugly cousin. linker errors, especially with
</em><br>
<em>&gt; STL code, are even more convoluted than C.
</em><br>
<em>&gt; - complexity/productivity. template soup is a great example. and yes,
</em><br>
<em>&gt; it still has pointers and memory housekeeping requirements, and yes,
</em><br>
<em>&gt; any plumbing work that is programming-language specific is a negative.
</em><br>
<em>&gt; Yes, some programmers thrive in this enviroment; however it is
</em><br>
<em>&gt; defnitely not competing when it comes to the RAD qualities of say,
</em><br>
<em>&gt; Perl or (gasp)VB.
</em><br>
<em>&gt; - Microsoft are dumping C++ like a brazilian baby. For all their
</em><br>
<em>&gt; faults, MS are a cluey bunch, especially when it comes to developers.
</em><br>
<em>&gt; They've got to have seen something plenty nasty in the bathwater to
</em><br>
<em>&gt; eat the cash-outlay gobstopper that is C#/.NET
</em><br>
<em>&gt;
</em><br>
<em>&gt; Java: The contender to replace C++ pretty much; the guys behind the
</em><br>
<em>&gt; language came out and said that they created Java to put the kiss of
</em><br>
<em>&gt; death to Bjarne's creation. This puppy is running some crucial
</em><br>
<em>&gt; high-load apps now, especially in finance. Also becoming the app layer
</em><br>
<em>&gt; of choice on mobiles through I doubt that's relevant here.
</em><br>
<em>&gt;
</em><br>
<em>&gt; positives:
</em><br>
<em>&gt; - a memory managed language; less programmer time spent playing
</em><br>
<em>&gt; nursemaid to an incomplete toolchain.
</em><br>
<em>&gt; - APIs/Libraries/Tools. The core API is simply enormous; if you want
</em><br>
<em>&gt; to do something, think of a class name that fits, and it'll probably
</em><br>
<em>&gt; be in the VM already. What isn't in their yet is probably either in
</em><br>
<em>&gt; the JSR's, sourceforge or IBM. Ant and JUnit(stack, incl things like
</em><br>
<em>&gt; HTTPUnit &amp; JCoverage) are truly revolutionary in the tool space. They
</em><br>
<em>&gt; make makefiles and test stubs look archaic.
</em><br>
<em>&gt; - developers. every tertiary institution on the planet is pumping them
</em><br>
<em>&gt; out like sperm. we can debate their veracity, but the simple fact is
</em><br>
<em>&gt; most coders (of _any_ langauge) couldn't give a rats' about coding an
</em><br>
<em>&gt; AGI so having a deeper resource pool has got to help
</em><br>
<em>&gt; - reflection. run-time introspection, querying the classloader etc.
</em><br>
<em>&gt; gives more flexibilty than most strong/static typed languages
</em><br>
<em>&gt; - remoting. RMI/EJB have their issues, but you have a distributed
</em><br>
<em>&gt; systems stack in the core API. CORBA for C/C++ is an inferior
</em><br>
<em>&gt; (supported) subset.
</em><br>
<em>&gt; - price. it's all pretty much free as in beer, and free as in open
</em><br>
<em>&gt; source otherwise, apart from the spec. this _does_ matter; thirty
</em><br>
<em>&gt; C/C++ VxWorks/Metrowerks/ADS developer licenses would sting a pretty
</em><br>
<em>&gt; penny.
</em><br>
<em>&gt;
</em><br>
<em>&gt; negatives:
</em><br>
<em>&gt; - slowness. Now, this is historically overblown, especially in
</em><br>
<em>&gt; relation to the original GUI (remember applets? anyone?) and I/O
</em><br>
<em>&gt; impementations which have either been superseded or obseleted. Having
</em><br>
<em>&gt; had a look at some of the Sun source code, their C/C++ programmers are
</em><br>
<em>&gt; kickass (think Solaris). They've spent years refactoring every
</em><br>
<em>&gt; bottleneck and apples-for-apples underperformer in comparison to STL
</em><br>
<em>&gt; C++ until the difference is often negligible (check their marketing
</em><br>
<em>&gt; 'fact'oids). And for performance over a longer run, the application
</em><br>
<em>&gt; servers with thier hacked JIT's and pre-loaded code means that Java
</em><br>
<em>&gt; gets quicker the longer you run it (discounting any leaks, which are,
</em><br>
<em>&gt; sadly, still present, though much reducied in comparision to early
</em><br>
<em>&gt; JDKs). Another thing is that slowness seems to pretty much be a
</em><br>
<em>&gt; non-issue where AGI development is concerned; by the time we finish
</em><br>
<em>&gt; hacking at the thing the hardware and tools will be generations
</em><br>
<em>&gt; better. You either need real-time; or you let Moore's law do your work
</em><br>
<em>&gt; for you. My Java apps from 1998 fly on newer RAM-stacked hardware.
</em><br>
<em>&gt; - strong+static typing. my feeling is that writing on-the-fly runtime
</em><br>
<em>&gt; customizable code is going to be needed to replicate what a brain can
</em><br>
<em>&gt; do. Reflection helps but isn't enough; Java is a little too
</em><br>
<em>&gt; monolithically structured when compared to something like Lisp; the
</em><br>
<em>&gt; code is very homogenous, and doesn't seem to have the agility to adapt
</em><br>
<em>&gt; well. I think this is somewhat intended to stop migrating VB
</em><br>
<em>&gt; developers from deciding they now want to be Perl programmers but it
</em><br>
<em>&gt; doesn't aid in dexterity.
</em><br>
<em>&gt;
</em><br>
<em>&gt; .NET/C#
</em><br>
<em>&gt; you can pretty much replicate everything said for Java here as it's a
</em><br>
<em>&gt; flat ripoff; that's why I think Sun had no qualms ripping off ASP and
</em><br>
<em>&gt; calling it JSP.
</em><br>
<em>&gt; positives: they've learned their lessons from Java's mistakes; most
</em><br>
<em>&gt; things are less broken in the IL and the CLR. It's early days though
</em><br>
<em>&gt; and some of the apps I've seen behave atrociously.
</em><br>
<em>&gt; negatives: price; no option for CLR hacking. And it's got to be said,
</em><br>
<em>&gt; MS are evil bastards; trying being a chair in Steve Ballmer's office,
</em><br>
<em>&gt; let alone Netscape, Sun or Real.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Perl
</em><br>
<em>&gt; OK I'll state my bias here; I've clearly coded in most of the others
</em><br>
<em>&gt; previously mentioned but Perl took my commercial programming virginity
</em><br>
<em>&gt; - and no, not doing CGI. Perl6/Parrot, while unfinished, seem to me to
</em><br>
<em>&gt; be pretty damn compelling. Once they have Parrot out with plugins for
</em><br>
<em>&gt; Lisp/Haskell/Java etc they'll have a pretty damn decent alternative to
</em><br>
<em>&gt; .NET. and having regex support within the syntax is just plain right.
</em><br>
<em>&gt;
</em><br>
<em>&gt; positives:
</em><br>
<em>&gt; - libraries. CPAN is huge; there's a module for most everything you
</em><br>
<em>&gt; can find in the Java API and plenty else besides
</em><br>
<em>&gt; - speed. competes tidily with C++, especially in batch processing.
</em><br>
<em>&gt; - typing. weak+dynamic. Perl doesn't care what it is or where it came
</em><br>
<em>&gt; from or what you're trying to do with it. 'use strict' can tighten the
</em><br>
<em>&gt; belt if needed for debugging. the auto/dynaloader magick allows
</em><br>
<em>&gt; run-time composition and execution of completely new
</em><br>
<em>&gt; functions/classes. The things the monks and their kin can do with this
</em><br>
<em>&gt; language is spectacular in a very scary way
</em><br>
<em>&gt;
</em><br>
<em>&gt; negatives:
</em><br>
<em>&gt; - oo. people knock their ISA implementation as a bolt-on. has always
</em><br>
<em>&gt; worked fine for me though. but it's definitely not as structured as
</em><br>
<em>&gt; say Java
</em><br>
<em>&gt; - complexity. weak+dynamic gives bad programmers license to kill. some
</em><br>
<em>&gt; perl code is unmaintainable. some wizards also take perverse pleasure
</em><br>
<em>&gt; in writing incredibly obfuscated code, unmatched outside of the
</em><br>
<em>&gt; functional languages I expect
</em><br>
<em>&gt; - toolset. perl is, well, fractured. it's a bit all over the place.
</em><br>
<em>&gt; you can get most anything to work, but just about everything is
</em><br>
<em>&gt; idiosyncratic as hell. Perl6/Parrot should put some kind of nail in
</em><br>
<em>&gt; this, but you never know with these crazy Perl nuts
</em><br>
<em>&gt;
</em><br>
<em>&gt; Lisp
</em><br>
<em>&gt; I have no sodding idea about Lisp apart from doing some reading
</em><br>
<em>&gt; recently and downloading a common Lisp compiler. That said, a good
</em><br>
<em>&gt; portion of the brightest minds in programming reserve a special status
</em><br>
<em>&gt; for Lisp.
</em><br>
<em>&gt; positives: functional/macro language right? good for self-evolving code
</em><br>
<em>&gt; negatives: Lisp already failed as the AI coding language of choice.
</em><br>
<em>&gt; Quibble all you like but it's 0 for 1, and AI Winter and the decline
</em><br>
<em>&gt; of Lisp seem interwined. Common Lisp doesn't even come close to
</em><br>
<em>&gt; matching the breadth of the bytecode-based APIs.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Candidates dismissed for discussion, and why:
</em><br>
<em>&gt; (these langauges seemed to me to have no standout qualities that
</em><br>
<em>&gt; belied their shortcomings; and basically they just don't compete in
</em><br>
<em>&gt; the same league as the heavyweights)
</em><br>
<em>&gt; Pascal/Delphi etc: subsets of C/C++
</em><br>
<em>&gt; Python/PHP/Ruby: subsets of Perl/Java, with piss all supporting
</em><br>
<em>&gt; libraries for non-web applications in comparison
</em><br>
<em>&gt; Haskell or functional-language-of-choice: Useful past the bootstrap
</em><br>
<em>&gt; level, and mixed in via say Parrot could be useful; but underweight
</em><br>
<em>&gt; for workhorse work in terms of developer-space  footprint
</em><br>
<em>&gt; ADA/Fortran archaic-failed-language-of-choice: nothing better than Lisp.
</em><br>
<em>&gt; Assembler/Machine language: all great, until you leave x86 to go to
</em><br>
<em>&gt; Cell chips; then you're stuffed
</em><br>
<p>OCaML is one plausible candidate.  Pretty fast, compileable &amp; interpretable.  
<br>
It's an Object Oriented dialect of CaML which is a dialect of ML.  SML 
<br>
doesn't have lots of nice features, like variables, but OCaML (and CaML?) 
<br>
slips them back in.  Also, ANSI C can be embedded into the code.  (So the 
<br>
docs say.  I'm not familiar enough to judge.)
<br>
<p>Have you looked at Alice, from Stanford University?  Still in the early 
<br>
stages, but it looks like it supports parallelism in a quite interesting 
<br>
fashion.  Check out &quot;Promises&quot;.  Nice!
<br>
<p>Also:  If you think of &quot;subsets of some other language&quot; as not worth 
<br>
considering, please think again.  Languages can be made much better by 
<br>
removing some feature that's just too dangerous.
<br>
<p>However, the real problem is:  &quot;Where are you going to get your programmers?&quot;.  
<br>
This is why so many projects settle on C or Java, despite all their many 
<br>
problems.  Even when you're paying good money most people are reluctant to 
<br>
learn a new language.  (I'm currently finding myself reluctant to learn OCaML 
<br>
for a somewhat similar reason.  It looks like a lot of effort for an 
<br>
uncertain return.)
<br>
<p>If you think that Python doesn't have any libraries outside of web 
<br>
programming, you've never looked at the Python libraries.  (That's true of 
<br>
Ruby also, but to a lesser extent.)   Also neither Python nor Ruby is very 
<br>
much like Java.   (I rather *like* coding in Python, and Ruby is almost a 
<br>
joy.  Unfortunately, they're a bit slow.  If you use them, figure you'll need 
<br>
twice the CPU cycles to reach breakthrough as with an efficient language, 
<br>
like C, D, or SML.  (Also, why include Perl?  It deserves to be dismissed for 
<br>
the same reasons, and to the same degree, as Python and Ruby.)
<br>
<p>If you think Ada doesn't have it's own unique strengths, you've never used it.  
<br>
It is, for the right kind of problem, the ideal tool.  But nobody knows the 
<br>
language, and doing lots of simple things takes huge amounts of code.   
<br>
(Also, it doesn't have a garbage collector.  That can be dealt with, but it's 
<br>
an extra hassle.)
<br>
<p>No comments on C#, but if you don't consider programmer availability, then I'd 
<br>
plunk clearly for D (unless you go for something experimental like Alice).  
<br>
If you do... SIGH ... it's pretty much GOT to be C, C++, or Java.  Perhaps 
<br>
the gcj subset of Java (so it's actually compileable to native code).
<br>
<!-- body="end" -->
<hr>
<ul>
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="13944.html">Patrick Crenshaw: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<li><strong>Previous message:</strong> <a href="13942.html">Richard Loosemore: "Languages for AGI  [WAS Re: Syllabus for Seed Developer Qualifications...]"</a>
<li><strong>In reply to:</strong> <a href="13939.html">Kevin Osborne: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="13944.html">Patrick Crenshaw: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<li><strong>Reply:</strong> <a href="13944.html">Patrick Crenshaw: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<li><strong>Reply:</strong> <a href="13946.html">Kevin Osborne: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#13943">[ date ]</a>
<a href="index.html#13943">[ thread ]</a>
<a href="subject.html#13943">[ subject ]</a>
<a href="author.html#13943">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<!-- trailer="footer" -->
<hr>
<p><small><em>
This archive was generated by <a href="http://www.hypermail.org/">hypermail 2.1.5</a> 
: Wed Jul 17 2013 - 04:00:55 MDT
</em></small></p>
</body>
</html>
