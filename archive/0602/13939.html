<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="generator" content="hypermail 2.1.5, see http://www.hypermail.org/">
<title>SL4: Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]</title>
<meta name="Author" content="Kevin Osborne (kevin.osborne@gmail.com)">
<meta name="Subject" content="Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]">
<meta name="Date" content="2006-02-01">
<style type="text/css">
body {color: black; background: #ffffff}
h1.center {text-align: center}
div.center {text-align: center}
</style>
</head>
<body>
<h1>Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]</h1>
<!-- received="Wed Feb  1 08:57:18 2006" -->
<!-- isoreceived="20060201155718" -->
<!-- sent="Thu, 2 Feb 2006 01:57:17 +1000" -->
<!-- isosent="20060201155717" -->
<!-- name="Kevin Osborne" -->
<!-- email="kevin.osborne@gmail.com" -->
<!-- subject="Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]" -->
<!-- id="3642969c0602010757p7be252dbyf7f24e620f6c870a@mail.gmail.com" -->
<!-- charset="ISO-8859-1" -->
<!-- inreplyto="16B00E05-015B-4700-ABAE-27F424E79199@ceruleansystems.com" -->
<!-- expires="-1" -->
<p>
<strong>From:</strong> Kevin Osborne (<a href="mailto:kevin.osborne@gmail.com?Subject=Re:%20Syllabus%20for%20Seed%20Developer%20Qualifications%20[WAS%20Re:%20Some%20considerations%20about%20AGI]"><em>kevin.osborne@gmail.com</em></a>)<br>
<strong>Date:</strong> Wed Feb 01 2006 - 08:57:17 MST
</p>
<!-- next="start" -->
<ul>
<li><strong>Next message:</strong> <a href="13940.html">Ben Goertzel: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<li><strong>Previous message:</strong> <a href="../0601/13938.html">Marc Geddes: "Re: My definitions of Intelligence, Consciousness, Mathematics and Universal Values"</a>
<li><strong>In reply to:</strong> <a href="../0601/13936.html">J. Andrew Rogers: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="13942.html">Richard Loosemore: "Languages for AGI  [WAS Re: Syllabus for Seed Developer Qualifications...]"</a>
<li><strong>Reply:</strong> <a href="13942.html">Richard Loosemore: "Languages for AGI  [WAS Re: Syllabus for Seed Developer Qualifications...]"</a>
<li><strong>Reply:</strong> <a href="13943.html">Charles D Hixson: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#13939">[ date ]</a>
<a href="index.html#13939">[ thread ]</a>
<a href="subject.html#13939">[ subject ]</a>
<a href="author.html#13939">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<hr>
<!-- body="start" -->
<p>
without putting a fire under yet another religious programming
<br>
language 'discussion' of attrition, I have what for me is an important
<br>
question in regards to AGI development and seed developer syllabus:
<br>
<p>what programming language are we going to code an AGI with?
<br>
<p>when answering this question I probably want to dismiss convoluted
<br>
combinations of systems, specialist languages/compilers that may
<br>
(already?) be developed for AGI purposes and focus on:
<br>
<p>what's the best language to develop the AGI workhorse code in?
<br>
<p>'workhorse' here means the code that will bridge the gap from the
<br>
not-so 'intelligent' systems we have now and be able to bootstrap a
<br>
higher semantic-language/instruction-set that will be part of the
<br>
first steps towards an AGI.
<br>
<p>Here's a hopefully not-too-biased critique-that-invites-critique of
<br>
some of the choices as they stand:
<br>
<p>C: I'm separating this from C++ as, well, most of the crack C
<br>
programmers I've worked with view C++ as some kind of leperous cousin;
<br>
they're able to make a host of criticisms of C++ in contrast to C but
<br>
I'm not one to repeat them succinctly I think. In summary;
<br>
positives:
<br>
- it's the fastest; without question. It also runs on every board on
<br>
the planet. There are a host of _great_ tools and compilers from the
<br>
likes of GCC, Sun, Intel, IBM, HP etc. If you want to write your own
<br>
OS kernel then you'll be doing it in C.
<br>
- the #1 choice for RTOS. if you want it to run real-time, it'll be in
<br>
C. I''ve personally had exposure to the VxWorks and Nucleus hard
<br>
real-time systems and a soft real-time Linux (Monta Vista). Even if
<br>
don't end up with
<br>
kernel=observer/ego/consciousness/insert-your-term-here, going
<br>
real-time seems to be an intuitive requirement for replicating a range
<br>
of faculties. That said, real-time code is very limited to what it can
<br>
do; it runs out of puff pretty quickly when climbing the OSI stack.
<br>
- Macros are a great language feature, and can provide some of the
<br>
extensibility and run-time switching needed.
<br>
- great debugging tools and lint collectors like Purify that can
<br>
pretty much guarantee against a number of errors like memory leaks and
<br>
overwrites
<br>
negatives:
<br>
- plumbing code. it just plain sucks to have to call memset, malloc
<br>
and free everywhere. #IFDEF may be damn useful but for me is ugly as
<br>
hell
<br>
- complexity/productivity. add all the plumbing code in; the need to
<br>
track and free all your resources; macros that obfuscate recursive &amp;
<br>
often cyclic function calls to n levels; the need to dick with your
<br>
defines both in the code and in the compiler, and the flag mess that
<br>
ensues when you are linking against every man and his dll and you end
<br>
up with a language great for low-level tweaking of the cpu instruction
<br>
set and a morass once it scales that eats huge amounts of programmer
<br>
time dicking with the maintenance of flags, variables and
<br>
linker/compiler bleats. this inevitibly sucks large amounts of time
<br>
away from higher-level functional work, especially during integration
<br>
with other people's code. I'd posit it as a given that we are going to
<br>
have to write more higher-level functional code than for any other
<br>
project ever attempted. To code the capabilities and faculties of
<br>
smart human is going to be a ridiculously huge endeavour. And once our
<br>
boy is smart enough he'll be rewriting himself bigger and bigger while
<br>
rewriting our code smaller and smaller. we just need to write
<br>
something big enough so that he has the capability to do so.
<br>
<p><p>C++: the current language of choice for all large critical systems
<br>
worldwide. The OSes are written in C, but the apps are in C++. When
<br>
your plane lands, it's C++; when the latest NASA space-gadget bleeps,
<br>
it's C++. The vast majority of apps that run global infrastructure are
<br>
in C++.
<br>
<p>positives:
<br>
- first things first; every VM and interpreter of note for the
<br>
bytecode/interpreted languages is written in C++.  A Java programmer
<br>
bitching about C++ is like a hand bitching about it's forearm. If you
<br>
want to hack your own special JIT or JVM, you'll need to be doing it
<br>
in C++
<br>
- Most of the RTOS vendors provide C++ APIs; so real-time application
<br>
development is available (for a cost)
<br>
- There's a larger body of support libraries available than for C when
<br>
it comes to higher-level functions; the STL is a great example
<br>
<p>negatives:
<br>
- as noted in one of the posts above, the toolset is awful in
<br>
comparison. g++ is gcc's ugly cousin. linker errors, especially with
<br>
STL code, are even more convoluted than C.
<br>
- complexity/productivity. template soup is a great example. and yes,
<br>
it still has pointers and memory housekeeping requirements, and yes,
<br>
any plumbing work that is programming-language specific is a negative.
<br>
Yes, some programmers thrive in this enviroment; however it is
<br>
defnitely not competing when it comes to the RAD qualities of say,
<br>
Perl or (gasp)VB.
<br>
- Microsoft are dumping C++ like a brazilian baby. For all their
<br>
faults, MS are a cluey bunch, especially when it comes to developers.
<br>
They've got to have seen something plenty nasty in the bathwater to
<br>
eat the cash-outlay gobstopper that is C#/.NET
<br>
<p>Java: The contender to replace C++ pretty much; the guys behind the
<br>
language came out and said that they created Java to put the kiss of
<br>
death to Bjarne's creation. This puppy is running some crucial
<br>
high-load apps now, especially in finance. Also becoming the app layer
<br>
of choice on mobiles through I doubt that's relevant here.
<br>
<p>positives:
<br>
- a memory managed language; less programmer time spent playing
<br>
nursemaid to an incomplete toolchain.
<br>
- APIs/Libraries/Tools. The core API is simply enormous; if you want
<br>
to do something, think of a class name that fits, and it'll probably
<br>
be in the VM already. What isn't in their yet is probably either in
<br>
the JSR's, sourceforge or IBM. Ant and JUnit(stack, incl things like
<br>
HTTPUnit &amp; JCoverage) are truly revolutionary in the tool space. They
<br>
make makefiles and test stubs look archaic.
<br>
- developers. every tertiary institution on the planet is pumping them
<br>
out like sperm. we can debate their veracity, but the simple fact is
<br>
most coders (of _any_ langauge) couldn't give a rats' about coding an
<br>
AGI so having a deeper resource pool has got to help
<br>
- reflection. run-time introspection, querying the classloader etc.
<br>
gives more flexibilty than most strong/static typed languages
<br>
- remoting. RMI/EJB have their issues, but you have a distributed
<br>
systems stack in the core API. CORBA for C/C++ is an inferior
<br>
(supported) subset.
<br>
- price. it's all pretty much free as in beer, and free as in open
<br>
source otherwise, apart from the spec. this _does_ matter; thirty
<br>
C/C++ VxWorks/Metrowerks/ADS developer licenses would sting a pretty
<br>
penny.
<br>
<p>negatives:
<br>
- slowness. Now, this is historically overblown, especially in
<br>
relation to the original GUI (remember applets? anyone?) and I/O
<br>
impementations which have either been superseded or obseleted. Having
<br>
had a look at some of the Sun source code, their C/C++ programmers are
<br>
kickass (think Solaris). They've spent years refactoring every
<br>
bottleneck and apples-for-apples underperformer in comparison to STL
<br>
C++ until the difference is often negligible (check their marketing
<br>
'fact'oids). And for performance over a longer run, the application
<br>
servers with thier hacked JIT's and pre-loaded code means that Java
<br>
gets quicker the longer you run it (discounting any leaks, which are,
<br>
sadly, still present, though much reducied in comparision to early
<br>
JDKs). Another thing is that slowness seems to pretty much be a
<br>
non-issue where AGI development is concerned; by the time we finish
<br>
hacking at the thing the hardware and tools will be generations
<br>
better. You either need real-time; or you let Moore's law do your work
<br>
for you. My Java apps from 1998 fly on newer RAM-stacked hardware.
<br>
- strong+static typing. my feeling is that writing on-the-fly runtime
<br>
customizable code is going to be needed to replicate what a brain can
<br>
do. Reflection helps but isn't enough; Java is a little too
<br>
monolithically structured when compared to something like Lisp; the
<br>
code is very homogenous, and doesn't seem to have the agility to adapt
<br>
well. I think this is somewhat intended to stop migrating VB
<br>
developers from deciding they now want to be Perl programmers but it
<br>
doesn't aid in dexterity.
<br>
<p>.NET/C#
<br>
you can pretty much replicate everything said for Java here as it's a
<br>
flat ripoff; that's why I think Sun had no qualms ripping off ASP and
<br>
calling it JSP.
<br>
positives: they've learned their lessons from Java's mistakes; most
<br>
things are less broken in the IL and the CLR. It's early days though
<br>
and some of the apps I've seen behave atrociously.
<br>
negatives: price; no option for CLR hacking. And it's got to be said,
<br>
MS are evil bastards; trying being a chair in Steve Ballmer's office,
<br>
let alone Netscape, Sun or Real.
<br>
<p>Perl
<br>
OK I'll state my bias here; I've clearly coded in most of the others
<br>
previously mentioned but Perl took my commercial programming virginity
<br>
- and no, not doing CGI. Perl6/Parrot, while unfinished, seem to me to
<br>
be pretty damn compelling. Once they have Parrot out with plugins for
<br>
Lisp/Haskell/Java etc they'll have a pretty damn decent alternative to
<br>
.NET. and having regex support within the syntax is just plain right.
<br>
<p>positives:
<br>
- libraries. CPAN is huge; there's a module for most everything you
<br>
can find in the Java API and plenty else besides
<br>
- speed. competes tidily with C++, especially in batch processing.
<br>
- typing. weak+dynamic. Perl doesn't care what it is or where it came
<br>
from or what you're trying to do with it. 'use strict' can tighten the
<br>
belt if needed for debugging. the auto/dynaloader magick allows
<br>
run-time composition and execution of completely new
<br>
functions/classes. The things the monks and their kin can do with this
<br>
language is spectacular in a very scary way
<br>
<p>negatives:
<br>
- oo. people knock their ISA implementation as a bolt-on. has always
<br>
worked fine for me though. but it's definitely not as structured as
<br>
say Java
<br>
- complexity. weak+dynamic gives bad programmers license to kill. some
<br>
perl code is unmaintainable. some wizards also take perverse pleasure
<br>
in writing incredibly obfuscated code, unmatched outside of the
<br>
functional languages I expect
<br>
- toolset. perl is, well, fractured. it's a bit all over the place.
<br>
you can get most anything to work, but just about everything is
<br>
idiosyncratic as hell. Perl6/Parrot should put some kind of nail in
<br>
this, but you never know with these crazy Perl nuts
<br>
<p>Lisp
<br>
I have no sodding idea about Lisp apart from doing some reading
<br>
recently and downloading a common Lisp compiler. That said, a good
<br>
portion of the brightest minds in programming reserve a special status
<br>
for Lisp.
<br>
positives: functional/macro language right? good for self-evolving code
<br>
negatives: Lisp already failed as the AI coding language of choice.
<br>
Quibble all you like but it's 0 for 1, and AI Winter and the decline
<br>
of Lisp seem interwined. Common Lisp doesn't even come close to
<br>
matching the breadth of the bytecode-based APIs.
<br>
<p>Candidates dismissed for discussion, and why:
<br>
(these langauges seemed to me to have no standout qualities that
<br>
belied their shortcomings; and basically they just don't compete in
<br>
the same league as the heavyweights)
<br>
Pascal/Delphi etc: subsets of C/C++
<br>
Python/PHP/Ruby: subsets of Perl/Java, with piss all supporting
<br>
libraries for non-web applications in comparison
<br>
Haskell or functional-language-of-choice: Useful past the bootstrap
<br>
level, and mixed in via say Parrot could be useful; but underweight
<br>
for workhorse work in terms of developer-space  footprint
<br>
ADA/Fortran archaic-failed-language-of-choice: nothing better than Lisp.
<br>
Assembler/Machine language: all great, until you leave x86 to go to
<br>
Cell chips; then you're stuffed
<br>
<!-- body="end" -->
<hr>
<ul>
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="13940.html">Ben Goertzel: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<li><strong>Previous message:</strong> <a href="../0601/13938.html">Marc Geddes: "Re: My definitions of Intelligence, Consciousness, Mathematics and Universal Values"</a>
<li><strong>In reply to:</strong> <a href="../0601/13936.html">J. Andrew Rogers: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="13942.html">Richard Loosemore: "Languages for AGI  [WAS Re: Syllabus for Seed Developer Qualifications...]"</a>
<li><strong>Reply:</strong> <a href="13942.html">Richard Loosemore: "Languages for AGI  [WAS Re: Syllabus for Seed Developer Qualifications...]"</a>
<li><strong>Reply:</strong> <a href="13943.html">Charles D Hixson: "Re: Syllabus for Seed Developer Qualifications [WAS Re: Some considerations about AGI]"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#13939">[ date ]</a>
<a href="index.html#13939">[ thread ]</a>
<a href="subject.html#13939">[ subject ]</a>
<a href="author.html#13939">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<!-- trailer="footer" -->
<hr>
<p><small><em>
This archive was generated by <a href="http://www.hypermail.org/">hypermail 2.1.5</a> 
: Wed Jul 17 2013 - 04:00:55 MDT
</em></small></p>
</body>
</html>
