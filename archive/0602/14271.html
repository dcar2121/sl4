<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="generator" content="hypermail 2.1.5, see http://www.hypermail.org/">
<title>SL4: Re: ESSAY: Program length, Omega and Friendliness</title>
<meta name="Author" content="William Pearson (wil.pearson@gmail.com)">
<meta name="Subject" content="Re: ESSAY: Program length, Omega and Friendliness">
<meta name="Date" content="2006-02-27">
<style type="text/css">
body {color: black; background: #ffffff}
h1.center {text-align: center}
div.center {text-align: center}
</style>
</head>
<body>
<h1>Re: ESSAY: Program length, Omega and Friendliness</h1>
<!-- received="Mon Feb 27 07:48:24 2006" -->
<!-- isoreceived="20060227144824" -->
<!-- sent="Mon, 27 Feb 2006 14:48:21 +0000" -->
<!-- isosent="20060227144821" -->
<!-- name="William Pearson" -->
<!-- email="wil.pearson@gmail.com" -->
<!-- subject="Re: ESSAY: Program length, Omega and Friendliness" -->
<!-- id="ab5bcc90602270648j249256cek@mail.gmail.com" -->
<!-- charset="ISO-8859-1" -->
<!-- inreplyto="6fdad3790602270525q1f7bc38u9a8ed2ee916d23ee@mail.gmail.com" -->
<!-- expires="-1" -->
<p>
<strong>From:</strong> William Pearson (<a href="mailto:wil.pearson@gmail.com?Subject=Re:%20ESSAY:%20Program%20length,%20Omega%20and%20Friendliness"><em>wil.pearson@gmail.com</em></a>)<br>
<strong>Date:</strong> Mon Feb 27 2006 - 07:48:21 MST
</p>
<!-- next="start" -->
<ul>
<li><strong>Next message:</strong> <a href="14272.html">Philip Goetz: "Re: ESSAY: Program length, Omega and Friendliness"</a>
<li><strong>Previous message:</strong> <a href="14270.html">Philip Goetz: "Re: ESSAY: Program length, Omega and Friendliness"</a>
<li><strong>In reply to:</strong> <a href="14270.html">Philip Goetz: "Re: ESSAY: Program length, Omega and Friendliness"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="14273.html">Philip Goetz: "Re: ESSAY: Program length, Omega and Friendliness"</a>
<li><strong>Reply:</strong> <a href="14273.html">Philip Goetz: "Re: ESSAY: Program length, Omega and Friendliness"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#14271">[ date ]</a>
<a href="index.html#14271">[ thread ]</a>
<a href="subject.html#14271">[ subject ]</a>
<a href="author.html#14271">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<hr>
<!-- body="start" -->
<p>
On 27/02/06, Philip Goetz &lt;<a href="mailto:philgoetz@gmail.com?Subject=Re:%20ESSAY:%20Program%20length,%20Omega%20and%20Friendliness">philgoetz@gmail.com</a>&gt; wrote:
<br>
<em>&gt; On 2/26/06, William Pearson &lt;<a href="mailto:wil.pearson@gmail.com?Subject=Re:%20ESSAY:%20Program%20length,%20Omega%20and%20Friendliness">wil.pearson@gmail.com</a>&gt; wrote:
</em><br>
<em>&gt; &gt; &gt; 2. This last bit about the maximum number of bits being bounded by
</em><br>
<em>&gt; &gt; &gt; your starting program.  That doesn't seem to connect to anything else
</em><br>
<em>&gt; &gt; &gt; in the proof.
</em><br>
<em>&gt; &gt;
</em><br>
<em>&gt; &gt; By programs in the following I shall mean programs whose kolmogorov
</em><br>
<em>&gt; &gt; complexity is equal to there length. That a program can know that an
</em><br>
<em>&gt; &gt; infinite number of programs that all do the same thing have the same
</em><br>
<em>&gt; &gt; halting likelyhood or friendliness is not interesting.
</em><br>
<em>&gt;
</em><br>
<em>&gt; If you limit yourself to programs whose K-complexity = their length,
</em><br>
<em>&gt; then you have destroyed the point of the exercise.  A program has 1
</em><br>
<em>&gt; K-complexity, so I think you are saying that &quot;The length of programs
</em><br>
<em>&gt; of length n that programs of length n can be transformed into is
</em><br>
<em>&gt; bounded by n&quot;.
</em><br>
<p>No I am not trying to say anything like that
<br>
<p>You miss out things like provably maintaining a certain programmatic
<br>
property such as friendliness. I also haven't bounded the length of
<br>
the programs to be transformed into, although a bound is possible.
<br>
<p><em>&gt; &gt; The thrust of the argument is this. Determining friendliness (or other
</em><br>
<em>&gt; &gt; desired property) of a program is as hard or harder as determining
</em><br>
<em>&gt; &gt; whether a program halts or an infinite looping program has finite
</em><br>
<em>&gt; &gt; output (whether it hangs or not).  Friendlyness implies (in a logical
</em><br>
<em>&gt; &gt; sense) the program halts.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Determining friendiness may be as hard as determining whether a
</em><br>
<em>&gt; program halts.  I don't know.  Why would friendliness imply that the
</em><br>
<em>&gt; program halts?  I don't see any connection.
</em><br>
<p>No? If a program doesn't halt it doesn't output (in the classical
<br>
formulation of halting). If it doesn't output it doesn't do anything.
<br>
Most definitions of friendliness definitely imply that programs are
<br>
supposed to do something. This may be non-obvious, because as  Richard
<br>
Loosemore we tend to think of AI programs as being infinite
<br>
outputting, so it might be clearer if I talked about whether a program
<br>
hangs or not rather than halts. However this discussion with you is
<br>
consuming the time that I can devote to that endeavour.
<br>
<p>I treat the halting problem as described in the final paragraph here.
<br>
<p><a href="http://www.cgl.uwaterloo.ca/~csk/halt/">http://www.cgl.uwaterloo.ca/~csk/halt/</a>
<br>
<p>Quote
<br>
[...] the halting problem is undecidable.
<br>
<p>In some sense, this problem (or some related formulation) is the
<br>
canonical undecidable problem. There are countless other undecidable
<br>
problems, which can often be expressed in terms of some simple
<br>
question about a computer program. For example:
<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;* Will the program ever print out a 5?
<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Will the program ever execute line 26?
<br>
<p>It turns out that these sorts of problems are all equivalent to the
<br>
halting problem, in the sense that given a solution to one of them,
<br>
you could write a solution to any of the other ones. The reasons why
<br>
that is possible are interesting, but beyond the scope of the last
<br>
sentence of this document.
<br>
Endquote
<br>
<p>I just substitute friendliness. Or strongly self-improving or other
<br>
property we want the program to maintain as it replaces itself with
<br>
new programs. I believe Rice's Theorem deals with the last sentence.
<br>
<p><a href="http://en.wikipedia.org/wiki/Rice%27s_theorem">http://en.wikipedia.org/wiki/Rice%27s_theorem</a>
<br>
<p><em>&gt; &gt; As all the bits of the Omega Series have no relation to each other,
</em><br>
<em>&gt; &gt; they are random so the shortest way of storing them is the direct
</em><br>
<em>&gt; &gt; information. And so because it is as hard or harder to prove
</em><br>
<em>&gt; &gt; friendliness Phi must be equally random.
</em><br>
<em>&gt; &gt;
</em><br>
<em>&gt; &gt; A proof system and axioms is a way of storing information about the
</em><br>
<em>&gt; &gt; world, we shall call a starting program with embedded proof system and
</em><br>
<em>&gt; &gt; axioms S.
</em><br>
<em>&gt; &gt;
</em><br>
<em>&gt; &gt; How many other programs can S prove the friendliness of?
</em><br>
<em>&gt; &gt;
</em><br>
<em>&gt; &gt; I have said the bound on the number of programs a proof system can
</em><br>
<em>&gt; &gt; have knowledge that they are friendly is the number of bits in it.
</em><br>
<em>&gt; &gt; Otherwise it has found some hidden relation between the bits of the
</em><br>
<em>&gt; &gt; Phi so that it can be compressed.
</em><br>
<em>&gt;
</em><br>
<em>&gt; Well, you're assuming, in advance, that there is no such thing as a
</em><br>
<em>&gt; proof system, but that instead, all the bits of Phi must be
</em><br>
<em>&gt; enumerated.  A proof system is generative, and a proof system of
</em><br>
<em>&gt; finite size can prove, for example, that an infinite number of numbers
</em><br>
<em>&gt; are either prime or not prime.
</em><br>
<p>This has no bearing on determining properties of strings that are
<br>
interpreted as programs. Primeness of a finite string can be
<br>
determined in finite time by a finite algorithm. Halting, and I argue
<br>
friendliness, cannot be. I would advise you to read some Chaitin if
<br>
you haven't.
<br>
<p><em>&gt; If you assume that there is no way to prove that a program is
</em><br>
<em>&gt; friendly, even then, it doesn't follow that you have to list one bit
</em><br>
<em>&gt; per program you know, because you may have heuristics that allow you
</em><br>
<em>&gt; to produce a prior probability for each program under consideration.
</em><br>
<p>This was distinctly beyond the scope of what I was arguing. It is fine
<br>
method if you accept that this has an arbitrary chance of having your
<br>
program hang or never halt as it replaces itself with new ones. To
<br>
give you a brief argument, if it can be shown that your heuristic
<br>
correctly assigns over 50% chance of halting to those programs that
<br>
halt and under 50% for those that don't halt for more programs than
<br>
its length, then it would lead to violation of the limits of knowing
<br>
Omega. If we can't or don't show this link then the correspondence of
<br>
the heuristic with reality is arbitrary.
<br>
<p>&nbsp;&nbsp;Will Pearson
<br>
<!-- body="end" -->
<hr>
<ul>
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="14272.html">Philip Goetz: "Re: ESSAY: Program length, Omega and Friendliness"</a>
<li><strong>Previous message:</strong> <a href="14270.html">Philip Goetz: "Re: ESSAY: Program length, Omega and Friendliness"</a>
<li><strong>In reply to:</strong> <a href="14270.html">Philip Goetz: "Re: ESSAY: Program length, Omega and Friendliness"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="14273.html">Philip Goetz: "Re: ESSAY: Program length, Omega and Friendliness"</a>
<li><strong>Reply:</strong> <a href="14273.html">Philip Goetz: "Re: ESSAY: Program length, Omega and Friendliness"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#14271">[ date ]</a>
<a href="index.html#14271">[ thread ]</a>
<a href="subject.html#14271">[ subject ]</a>
<a href="author.html#14271">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<!-- trailer="footer" -->
<hr>
<p><small><em>
This archive was generated by <a href="http://www.hypermail.org/">hypermail 2.1.5</a> 
: Wed Jul 17 2013 - 04:00:56 MDT
</em></small></p>
</body>
</html>
